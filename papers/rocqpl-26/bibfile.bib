% Memory models
@article{lamport-sc,
  author    = {Leslie Lamport},
  title     = {How to Make a Multiprocessor Computer That Correctly Executes Multiprocess
               Programs},
  journal   = {{IEEE} Trans. Computers},
  volume    = {28},
  number    = {9},
  pages     = {690--691},
  year      = {1979},
  url       = {https://doi.org/10.1109/TC.1979.1675439},
  doi       = {10.1109/TC.1979.1675439},
  timestamp = {Wed, 14 Nov 2018 10:48:33 +0100},
  biburl    = {https://dblp.org/rec/journals/tc/Lamport79.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{batty+:c11-popl11,
  author    = {Mark Batty and
               Scott Owens and
               Susmit Sarkar and
               Peter Sewell and
               Tjark Weber},
  title     = {Mathematizing {C++} concurrency},
  booktitle = {Proceedings of the 38th {ACM} {SIGPLAN-SIGACT} Symposium on Principles
               of Programming Languages, {POPL} 2011, Austin, TX, USA, January 26-28,
               2011},
  pages     = {55--66},
  publisher = {{ACM}},
  year      = {2011},
  url       = {https://doi.org/10.1145/1926385.1926394},
  doi       = {10.1145/1926385.1926394},
  timestamp = {Thu, 24 Jun 2021 16:19:31 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/BattyOSSW11.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{c11-power,
author = {Batty, Mark and Memarian, Kayvan and Owens, Scott and Sarkar, Susmit and Sewell, Peter},
title = {Clarifying and Compiling C/C++ Concurrency: From C++11 to POWER},
year = {2012},
isbn = {9781450310833},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2103656.2103717},
doi = {10.1145/2103656.2103717},
abstract = {The upcoming C and C++ revised standards add concurrency to the languages, for the first time, in the form of a subtle *relaxed memory model* (the *C++11 model*). This aims to permit compiler optimisation and to accommodate the differing relaxed-memory behaviours of mainstream multiprocessors, combining simple semantics for most code with high-performance *low-level atomics* for concurrency libraries. In this paper, we first establish two simpler but provably equivalent models for C++11, one for the full language and another for the subset without consume operations. Subsetting further to the fragment without low-level atomics, we identify a subtlety arising from atomic initialisation and prove that, under an additional condition, the model is equivalent to sequential consistency for race-free programs.We then prove our main result, the correctness of two proposed compilation schemes for the C++11 load and store concurrency primitives to Power assembly, having noted that an earlier proposal was flawed. (The main ideas apply also to ARM, which has a similar relaxed memory architecture.)This should inform the ongoing development of production compilers for C++11 and C1x, clarifies what properties of the machine architecture are required, and builds confidence in the C++11 and Power semantics.},
booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {509–520},
numpages = {12},
keywords = {relaxed memory models, semantics},
location = {Philadelphia, PA, USA},
series = {POPL '12}
}

@inproceedings{promising,
  author    = {Jeehoon Kang and
               Chung{-}Kil Hur and
               Ori Lahav and
               Viktor Vafeiadis and
               Derek Dreyer},
  title     = {A promising semantics for relaxed-memory concurrency},
  booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of
               Programming Languages, {POPL} 2017, Paris, France, January 18-20,
               2017},
  pages     = {175--189},
  publisher = {{ACM}},
  year      = {2017},
  url       = {https://doi.org/10.1145/3009837.3009850},
  doi       = {10.1145/3009837.3009850},
  timestamp = {Thu, 14 Oct 2021 09:53:19 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/KangHLVD17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{rc11,
  author    = {Ori Lahav and
               Viktor Vafeiadis and
               Jeehoon Kang and
               Chung{-}Kil Hur and
               Derek Dreyer},
  title     = {Repairing sequential consistency in {C/C++11}},
  booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, {PLDI} 2017, Barcelona, Spain,
               June 18-23, 2017},
  pages     = {618--632},
  publisher = {{ACM}},
  year      = {2017},
  url       = {https://doi.org/10.1145/3062341.3062352},
  doi       = {10.1145/3062341.3062352},
  timestamp = {Wed, 23 Jun 2021 15:34:31 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/LahavVKHD17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{pulte+:arm-popl17,
  author    = {Christopher Pulte and
               Shaked Flur and
               Will Deacon and
               Jon French and
               Susmit Sarkar and
               Peter Sewell},
  title     = {Simplifying {ARM} concurrency: multicopy-atomic axiomatic and operational
               models for ARMv8},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {2},
  number    = {{POPL}},
  pages     = {19:1--19:29},
  year      = {2018},
  url       = {https://doi.org/10.1145/3158107},
  doi       = {10.1145/3158107},
  timestamp = {Wed, 17 Feb 2021 08:54:04 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/PulteFDFSS18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{dolan+:ocaml-pldi18,
  author    = {Stephen Dolan and
               K. C. Sivaramakrishnan and
               Anil Madhavapeddy},
  title     = {Bounding data races in space and time},
  booktitle = {Proceedings of the 39th {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, {PLDI} 2018, Philadelphia, PA,
               USA, June 18-22, 2018},
  pages     = {242--255},
  publisher = {{ACM}},
  year      = {2018},
  url       = {https://doi.org/10.1145/3192366.3192421},
  doi       = {10.1145/3192366.3192421},
  timestamp = {Wed, 23 Jun 2021 15:34:31 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/DolanSM18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{pulte+:promising-arm-pldi19,
  author    = {Christopher Pulte and
               Jean Pichon{-}Pharabod and
               Jeehoon Kang and
               Sung Hwan Lee and
               Chung{-}Kil Hur},
  title     = {Promising-{ARM}/{RISC-V}: a simpler and faster operational concurrency
               model},
  booktitle = {Proceedings of the 40th {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, {PLDI} 2019, Phoenix, AZ, USA,
               June 22-26, 2019},
  pages     = {1--15},
  publisher = {{ACM}},
  year      = {2019},
  url       = {https://doi.org/10.1145/3314221.3314624},
  doi       = {10.1145/3314221.3314624},
  timestamp = {Sun, 09 Jun 2019 19:00:05 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/PultePKLH19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{bender+:java-oopsla19,
  author    = {John Bender and
               Jens Palsberg},
  title     = {A formalization of Java's concurrent access modes},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{OOPSLA}},
  pages     = {142:1--142:28},
  year      = {2019},
  url       = {https://doi.org/10.1145/3360568},
  doi       = {10.1145/3360568},
  timestamp = {Wed, 17 Feb 2021 08:54:07 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/BenderP19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{chakraborty+:events-popl19,
  author    = {Soham Chakraborty and
               Viktor Vafeiadis},
  title     = {Grounding thin-air reads with event structures},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{POPL}},
  pages     = {70:1--70:28},
  year      = {2019},
  url       = {https://doi.org/10.1145/3290383},
  doi       = {10.1145/3290383},
  timestamp = {Wed, 16 Jun 2021 16:07:35 +0200},
  biburl    = {https://dblp.org/rec/journals/pacmpl/ChakrabortyV19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{watt+:javascript-pldi20,
  author    = {Conrad Watt and
               Christopher Pulte and
               Anton Podkopaev and
               Guillaume Barbier and
               Stephen Dolan and
               Shaked Flur and
               Jean Pichon{-}Pharabod and
               Shu{-}yu Guo},
  title     = {Repairing and mechanising the JavaScript relaxed memory model},
  booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} International Conference on
               Programming Language Design and Implementation, {PLDI} 2020, London,
               UK, June 15-20, 2020},
  pages     = {346--361},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3385412.3385973},
  doi       = {10.1145/3385412.3385973},
  timestamp = {Thu, 21 Jan 2021 17:36:44 +0100},
  biburl    = {https://dblp.org/rec/conf/pldi/WattPPBDFPG20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{lee+:promising2-pldi20,
  author    = {Sung{-}Hwan Lee and
               Minki Cho and
               Anton Podkopaev and
               Soham Chakraborty and
               Chung{-}Kil Hur and
               Ori Lahav and
               Viktor Vafeiadis},
  title     = {Promising 2.0: global optimizations in relaxed memory concurrency},
  booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} International Conference on
               Programming Language Design and Implementation, {PLDI} 2020, London,
               UK, June 15-20, 2020},
  pages     = {362--376},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3385412.3386010},
  doi       = {10.1145/3385412.3386010},
  timestamp = {Wed, 16 Jun 2021 16:07:37 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/LeeCPCHLV20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Histories
@inproceedings{sergey+:history-esop15,
  author    = {Ilya Sergey and
               Aleksandar Nanevski and
               Anindya Banerjee},
  title     = {Specifying and Verifying Concurrent Algorithms with Histories and
               Subjectivity},
  booktitle = {Programming Languages and Systems - 24th European Symposium on Programming,
               {ESOP} 2015, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2015, London, UK, April 11-18, 2015.
               Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9032},
  pages     = {333--358},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-662-46669-8\_14},
  doi       = {10.1007/978-3-662-46669-8\_14},
  timestamp = {Tue, 20 Aug 2019 15:27:49 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/SergeyNB15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{sergey+:history-oopsla16,
  author    = {Ilya Sergey and
               Aleksandar Nanevski and
               Anindya Banerjee and
               Germ{\'{a}}n Andr{\'{e}}s Delbianco},
  title     = {Hoare-style specifications as correctness conditions for non-linearizable
               concurrent objects},
  booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               {OOPSLA} 2016, part of {SPLASH} 2016, Amsterdam, The Netherlands,
               October 30 - November 4, 2016},
  pages     = {92--110},
  publisher = {{ACM}},
  year      = {2016},
  url       = {https://doi.org/10.1145/2983990.2983999},
  doi       = {10.1145/2983990.2983999},
  timestamp = {Wed, 23 Jun 2021 15:34:31 +0200},
  biburl    = {https://dblp.org/rec/conf/oopsla/SergeyNBD16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{delbianco+:linkedtime-ecoop17,
  author    = {Germ{\'{a}}n Andr{\'{e}}s Delbianco and
               Ilya Sergey and
               Aleksandar Nanevski and
               Anindya Banerjee},
  title     = {Concurrent Data Structures Linked in Time},
  booktitle = {31st European Conference on Object-Oriented Programming, {ECOOP} 2017,
               June 19-23, 2017, Barcelona, Spain},
  series    = {LIPIcs},
  volume    = {74},
  pages     = {8:1--8:30},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2017},
  url       = {https://doi.org/10.4230/LIPIcs.ECOOP.2017.8},
  doi       = {10.4230/LIPIcs.ECOOP.2017.8},
  timestamp = {Tue, 11 Feb 2020 15:52:14 +0100},
  biburl    = {https://dblp.org/rec/conf/ecoop/DelbiancoSNB17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{birkedal+:theorems-icfp21,
  author    = {Lars Birkedal and
               Thomas Dinsdale{-}Young and
               Arma{\"{e}}l Gu{\'{e}}neau and
               Guilhem Jaber and
               Kasper Svendsen and
               Nikos Tzevelekos},
  title     = {Theorems for free from separation logic specifications},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {5},
  number    = {{ICFP}},
  pages     = {1--29},
  year      = {2021},
  url       = {https://doi.org/10.1145/3473586},
  doi       = {10.1145/3473586},
  timestamp = {Mon, 30 Aug 2021 17:42:44 +0200},
  biburl    = {https://dblp.org/rec/journals/pacmpl/BirkedalDGJST21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Prophecy
@article{jung+:prophecy-popl20,
  author    = {Ralf Jung and
               Rodolphe Lepigre and
               Gaurav Parthasarathy and
               Marianna Rapoport and
               Amin Timany and
               Derek Dreyer and
               Bart Jacobs},
  title     = {The future is ours: prophecy variables in separation logic},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {4},
  number    = {{POPL}},
  pages     = {45:1--45:32},
  year      = {2020},
  url       = {https://doi.org/10.1145/3371113},
  doi       = {10.1145/3371113},
  timestamp = {Wed, 17 Feb 2021 08:54:02 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/JungLPRTDJ20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Abadi+Lamport:prophecy-88,
  author    = {Mart{\'{\i}}n Abadi and
               Leslie Lamport},
  title     = {The Existence of Refinement Mappings},
  booktitle = {Proceedings of the Third Annual Symposium on Logic in Computer Science
               {(LICS} '88), Edinburgh, Scotland, UK, July 5-8, 1988},
  pages     = {165--175},
  publisher = {{IEEE} Computer Society},
  year      = {1988},
  url       = {https://doi.org/10.1109/LICS.1988.5115},
  doi       = {10.1109/LICS.1988.5115},
  timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
  biburl    = {https://dblp.org/rec/conf/lics/AbadiL88.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{Abadi+Lamport:prophecy-91,
  author    = {Mart{\'{\i}}n Abadi and
               Leslie Lamport},
  title     = {The Existence of Refinement Mappings},
  journal   = {Theor. Comput. Sci.},
  volume    = {82},
  number    = {2},
  pages     = {253--284},
  year      = {1991},
  url       = {https://doi.org/10.1016/0304-3975(91)90224-P},
  doi       = {10.1016/0304-3975(91)90224-P},
  timestamp = {Wed, 17 Feb 2021 21:59:17 +0100},
  biburl    = {https://dblp.org/rec/journals/tcs/AbadiL91.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Aspect
@article{henzinger+:aspect-concur13,
  author    = {Thomas A. Henzinger and
               Ali Sezgin and
               Viktor Vafeiadis},
  title     = {Aspect-Oriented Linearizability Proofs},
  booktitle = {{CONCUR} 2013 - Concurrency Theory - 24th International Conference,
               {CONCUR} 2013, Buenos Aires, Argentina, August 27-30, 2013. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {8052},
  pages     = {242--256},
  publisher = {Springer},
  year      = {2013},
  url       = {https://doi.org/10.1007/978-3-642-40184-8\_18},
  doi       = {10.1007/978-3-642-40184-8\_18},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/conf/concur/HenzingerSV13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{chakraborty+:aspect-lmcs15,
  author    = {Soham Chakraborty and
               Thomas A. Henzinger and
               Ali Sezgin and
               Viktor Vafeiadis},
  title     = {Aspect-oriented linearizability proofs},
  journal   = {Log. Methods Comput. Sci.},
  volume    = {11},
  number    = {1},
  year      = {2015},
  url       = {https://doi.org/10.2168/LMCS-11(1:20)2015},
  doi       = {10.2168/LMCS-11(1:20)2015},
  timestamp = {Wed, 16 Jun 2021 16:07:36 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/ChakrabortyHSV15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Partial orders
@inproceedings{hemed+:cal-disc15,
  author    = {Nir Hemed and
               Noam Rinetzky and
               Viktor Vafeiadis},
  title     = {Modular Verification of Concurrency-Aware Linearizability},
  booktitle = {Distributed Computing - 29th International Symposium, {DISC} 2015,
               Tokyo, Japan, October 7-9, 2015, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9363},
  pages     = {371--387},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-662-48653-5\_25},
  doi       = {10.1007/978-3-662-48653-5\_25},
  timestamp = {Tue, 14 May 2019 10:00:54 +0200},
  biburl    = {https://dblp.org/rec/conf/wdag/HemedRV15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{derrick+:quiescent-fm14,
  author    = {John Derrick and
               Brijesh Dongol and
               Gerhard Schellhorn and
               Bogdan Tofan and
               Oleg Travkin and
               Heike Wehrheim},
  title     = {Quiescent Consistency: Defining and Verifying Relaxed Linearizability},
  booktitle = {{FM} 2014: Formal Methods - 19th International Symposium, Singapore,
               May 12-16, 2014. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {8442},
  pages     = {200--214},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-319-06410-9\_15},
  doi       = {10.1007/978-3-319-06410-9\_15},
  timestamp = {Mon, 16 Sep 2019 15:30:43 +0200},
  biburl    = {https://dblp.org/rec/conf/fm/DerrickDSTTW14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{afek+:quasi-ds10,
  author    = {Yehuda Afek and
               Guy Korland and
               Eitan Yanovsky},
  title     = {Quasi-Linearizability: Relaxed Consistency for Improved Concurrency},
  booktitle = {Principles of Distributed Systems - 14th International Conference,
               {OPODIS} 2010, Tozeur, Tunisia, December 14-17, 2010. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {6490},
  pages     = {395--410},
  publisher = {Springer},
  year      = {2010},
  url       = {https://doi.org/10.1007/978-3-642-17653-1\_29},
  doi       = {10.1007/978-3-642-17653-1\_29},
  timestamp = {Tue, 05 Nov 2019 12:22:56 +0100},
  biburl    = {https://dblp.org/rec/conf/opodis/AfekKY10.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{Henzinger+:qr-popl13,
  author    = {Thomas A. Henzinger and
               Christoph M. Kirsch and
               Hannes Payer and
               Ali Sezgin and
               Ana Sokolova},
  title     = {Quantitative relaxation of concurrent data structures},
  booktitle = {The 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
               Programming Languages, {POPL} '13, Rome, Italy - January 23 - 25,
               2013},
  pages     = {317--328},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2429069.2429109},
  doi       = {10.1145/2429069.2429109},
  timestamp = {Thu, 24 Jun 2021 16:19:31 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/HenzingerKPSS13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@InProceedings{Jagadeesan+:qqc-icalp14,
  author    = {Radha Jagadeesan and
               James Riely},
  title     = {Between Linearizability and Quiescent Consistency - Quantitative Quiescent
               Consistency},
  booktitle = {Automata, Languages, and Programming - 41st International Colloquium,
               {ICALP} 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part
               {II}},
  series    = {Lecture Notes in Computer Science},
  volume    = {8573},
  pages     = {220--231},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-662-43951-7\_19},
  doi       = {10.1007/978-3-662-43951-7\_19},
  timestamp = {Tue, 14 May 2019 10:00:44 +0200},
  biburl    = {https://dblp.org/rec/conf/icalp/JagadeesanR14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{Jagadeesan+:quarantine-esop13,
  author    = {Radha Jagadeesan and
               Gustavo Petri and
               Corin Pitcher and
               James Riely},
  title     = {Quarantining Weakness - Compositional Reasoning under Relaxed Memory
               Models (Extended Abstract)},
  booktitle = {Programming Languages and Systems - 22nd European Symposium on Programming,
               {ESOP} 2013, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2013, Rome, Italy, March 16-24,
               2013. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {7792},
  pages     = {492--511},
  publisher = {Springer},
  year      = {2013},
  url       = {https://doi.org/10.1007/978-3-642-37036-6\_27},
  doi       = {10.1007/978-3-642-37036-6\_27},
  timestamp = {Tue, 14 May 2019 10:00:41 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/JagadeesanPPR13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{haas+:local-lin-concur16,
  author    = {Andreas Haas and
               Thomas A. Henzinger and
               Andreas Holzer and
               Christoph M. Kirsch and
               Michael Lippautz and
               Hannes Payer and
               Ali Sezgin and
               Ana Sokolova and
               Helmut Veith},
  title     = {Local Linearizability for Concurrent Container-Type Data Structures},
  booktitle = {27th International Conference on Concurrency Theory, {CONCUR} 2016,
               August 23-26, 2016, Qu{\'{e}}bec City, Canada},
  series    = {LIPIcs},
  volume    = {59},
  pages     = {6:1--6:15},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2016},
  url       = {https://doi.org/10.4230/LIPIcs.CONCUR.2016.6},
  doi       = {10.4230/LIPIcs.CONCUR.2016.6},
  timestamp = {Fri, 27 Mar 2020 08:51:56 +0100},
  biburl    = {https://dblp.org/rec/conf/concur/HaasHHKLPSSV16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@InProceedings{khyzha+:po-esop17,
  author    = {Artem Khyzha and
               Mike Dodds and
               Alexey Gotsman and
               Matthew J. Parkinson},
  title     = {Proving Linearizability Using Partial Orders},
  booktitle = {Programming Languages and Systems - 26th European Symposium on Programming,
               {ESOP} 2017, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2017, Uppsala, Sweden, April 22-29,
               2017, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {10201},
  pages     = {639--667},
  publisher = {Springer},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-662-54434-1\_24},
  doi       = {10.1007/978-3-662-54434-1\_24},
  timestamp = {Sun, 25 Oct 2020 23:07:09 +0100},
  biburl    = {https://dblp.org/rec/conf/esop/KhyzhaDGP17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{krishna+:visibility-esop20,
  author    = {Siddharth Krishna and
               Michael Emmi and
               Constantin Enea and
               Dejan Jovanovic},
  title     = {Verifying Visibility-Based Weak Consistency},
  booktitle = {Programming Languages and Systems - 29th European Symposium on Programming,
               {ESOP} 2020, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2020, Dublin, Ireland, April 25-30,
               2020, Proceedings},
  series    = {Lecture Notes in Computer Science},
  pages     = {280--307},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-44914-8\_11},
  doi       = {10.1007/978-3-030-44914-8\_11},
  timestamp = {Wed, 22 Sep 2021 15:48:24 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/KrishnaEEJ20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@article{emmi+:weak-con-popl19,
  author    = {Michael Emmi and
               Constantin Enea},
  title     = {Weak-consistency specification via visibility relaxation},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{POPL}},
  pages     = {60:1--60:28},
  year      = {2019},
  url       = {https://doi.org/10.1145/3290373},
  doi       = {10.1145/3290373},
  timestamp = {Wed, 17 Feb 2021 08:54:09 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/EmmiE19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{burckhardt+:tso-lib-esop12,
  author    = {Sebastian Burckhardt and
               Alexey Gotsman and
               Madanlal Musuvathi and
               Hongseok Yang},
  title     = {Concurrent Library Correctness on the {TSO} Memory Model},
  booktitle = {Programming Languages and Systems - 21st European Symposium on Programming,
               {ESOP} 2012, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2012, Tallinn, Estonia, March 24
               - April 1, 2012. Proceedings},
  pages     = {87--107},
  year      = {2012},
  url       = {https://doi.org/10.1007/978-3-642-28869-2\_5},
  doi       = {10.1007/978-3-642-28869-2\_5},
  timestamp = {Tue, 14 May 2019 10:00:41 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/BurckhardtGMY12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{burckhardt+:eventual-popl14,
  author    = {Sebastian Burckhardt and
               Alexey Gotsman and
               Hongseok Yang and
               Marek Zawirski},
  title     = {Replicated data types: specification, verification, optimality},
  booktitle = {The 41st Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
               Programming Languages, {POPL} '14, San Diego, CA, USA, January 20-21,
               2014},
  pages     = {271--284},
  publisher = {{ACM}},
  year      = {2014},
  url       = {https://doi.org/10.1145/2535838.2535848},
  doi       = {10.1145/2535838.2535848},
  timestamp = {Thu, 24 Jun 2021 16:19:31 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/BurckhardtGYZ14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{raad+:libcorrect-popl19,
  author    = {Azalea Raad and
               Marko Doko and
               Lovro Rozic and
               Ori Lahav and
               Viktor Vafeiadis},
  title     = {On library correctness under weak memory consistency: specifying and
               verifying concurrent libraries under declarative consistency models},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{POPL}},
  pages     = {68:1--68:31},
  year      = {2019},
  url       = {https://doi.org/10.1145/3290381},
  doi       = {10.1145/3290381},
  timestamp = {Wed, 17 Feb 2021 08:53:57 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/RaadDRLV19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{doherty+:po-lin-ifm18,
  author    = {Simon Doherty and
               Brijesh Dongol and
               Heike Wehrheim and
               John Derrick},
  title     = {Making Linearizability Compositional for Partially Ordered Executions},
  booktitle = {Integrated Formal Methods - 14th International Conference, {IFM} 2018,
               Maynooth, Ireland, September 5-7, 2018, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {11023},
  pages     = {110--129},
  publisher = {Springer},
  year      = {2018},
  url       = {https://doi.org/10.1007/978-3-319-98938-9\_7},
  doi       = {10.1007/978-3-319-98938-9\_7},
  timestamp = {Wed, 25 Sep 2019 18:10:54 +0200},
  biburl    = {https://dblp.org/rec/conf/ifm/DohertyDWD18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{dongol+:wk-lin-vmcai18,
  author    = {Brijesh Dongol and
               Radha Jagadeesan and
               James Riely and
               Alasdair Armstrong},
  title     = {On abstraction and compositionality for weak-memory linearisability},
  booktitle = {Verification, Model Checking, and Abstract Interpretation - 19th International
               Conference, {VMCAI} 2018, Los Angeles, CA, USA, January 7-9, 2018,
               Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {10747},
  pages     = {183--204},
  publisher = {Springer},
  year      = {2018},
  url       = {https://doi.org/10.1007/978-3-319-73721-8\_9},
  doi       = {10.1007/978-3-319-73721-8\_9},
  timestamp = {Wed, 25 Sep 2019 18:20:13 +0200},
  biburl    = {https://dblp.org/rec/conf/vmcai/DongolJRA18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{batty+:libabs-popl13,
  author    = {Mark Batty and
               Mike Dodds and
               Alexey Gotsman},
  title     = {Library abstraction for {C/C++} concurrency},
  booktitle = {The 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
               Programming Languages, {POPL} '13, Rome, Italy - January 23 - 25,
               2013},
  pages     = {235--248},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2429069.2429099},
  doi       = {10.1145/2429069.2429099},
  timestamp = {Thu, 24 Jun 2021 16:19:31 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/BattyDG13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{neiger:set-lin-podc94,
  author    = {Gil Neiger},
  title     = {Set-Linearizability},
  booktitle = {Proceedings of the Thirteenth Annual {ACM} Symposium on Principles
               of Distributed Computing, Los Angeles, California, USA, August 14-17,
               1994},
  pages     = {396},
  publisher = {{ACM}},
  year      = {1994},
  url       = {https://doi.org/10.1145/197917.198176},
  doi       = {10.1145/197917.198176},
  timestamp = {Tue, 06 Nov 2018 11:07:18 +0100},
  biburl    = {https://dblp.org/rec/conf/podc/Neiger94.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{castaneda+:tasks-disc15,
  author    = {Armando Casta{\~{n}}eda and
               Sergio Rajsbaum and
               Michel Raynal},
  title     = {Specifying Concurrent Problems: Beyond Linearizability and up to Tasks
               - (Extended Abstract)},
  booktitle = {Distributed Computing - 29th International Symposium, {DISC} 2015,
               Tokyo, Japan, October 7-9, 2015, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9363},
  pages     = {420--435},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-662-48653-5\_28},
  doi       = {10.1007/978-3-662-48653-5\_28},
  timestamp = {Tue, 14 May 2019 10:00:54 +0200},
  biburl    = {https://dblp.org/rec/conf/wdag/CastanedaRR15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Linearizability
@article{herlihy-wing:linearizability,
  author    = {Maurice Herlihy and
               Jeannette M. Wing},
  title     = {Linearizability: {A} Correctness Condition for Concurrent Objects},
  journal   = {{ACM} Trans. Program. Lang. Syst.},
  volume    = {12},
  number    = {3},
  pages     = {463--492},
  year      = {1990},
  url       = {https://doi.org/10.1145/78969.78972},
  doi       = {10.1145/78969.78972},
  timestamp = {Wed, 14 Nov 2018 10:30:40 +0100},
  biburl    = {https://dblp.org/rec/journals/toplas/HerlihyW90.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{lin-refinement,
author="Filipovi{\'{c}}, Ivana
and O'Hearn, Peter
and Rinetzky, Noam
and Yang, Hongseok",
editor="Castagna, Giuseppe",
title="Abstraction for Concurrent Objects",
booktitle="Programming Languages and Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="252--266",
abstract="Concurrent data structures are usually designed to satisfy correctness conditions such as sequential consistency and linearizability. In this paper, we consider the following fundamental question: what guarantees are provided by these conditions for client programs? We formally show that these conditions can be characterized in terms of observational refinement. Our study also provides a new understanding of sequential consistency and linearizability in terms of abstraction of dependency between computation steps of client programs.",
isbn="978-3-642-00590-9"
}

% RAR Owicki-Gries, object semantics, refinement
@InProceedings{dalvandi+:owicki-gries-ecoop20,
  author    = {Sadegh Dalvandi and
               Simon Doherty and
               Brijesh Dongol and
               Heike Wehrheim},
  title     = {Owicki-Gries Reasoning for {C11} {RAR}},
  booktitle = {34th European Conference on Object-Oriented Programming, {ECOOP} 2020,
               November 15-17, 2020, Berlin, Germany (Virtual Conference)},
  series    = {LIPIcs},
  volume    = {166},
  pages     = {11:1--11:26},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2020},
  url       = {https://doi.org/10.4230/LIPIcs.ECOOP.2020.11},
  doi       = {10.4230/LIPIcs.ECOOP.2020.11},
  timestamp = {Mon, 21 Dec 2020 13:23:22 +0100},
  biburl    = {https://dblp.org/rec/conf/ecoop/DalvandiDDW19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{dalvandi+:c11style-ppopp21,
  author    = {Sadegh Dalvandi and
               Brijesh Dongol},
  title     = {Verifying {C11}-style weak memory libraries},
  booktitle = {PPoPP '21: 26th {ACM} {SIGPLAN} Symposium on Principles and Practice
               of Parallel Programming, Virtual Event, Republic of Korea, February
               27- March 3, 2021},
  pages     = {451--453},
  publisher = {{ACM}},
  year      = {2021},
  url       = {https://doi.org/10.1145/3437801.3441619},
  doi       = {10.1145/3437801.3441619},
  timestamp = {Wed, 24 Feb 2021 18:09:33 +0100},
  biburl    = {https://dblp.org/rec/conf/ppopp/DalvandiD21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{dalvandi+:c11style-arxiv,
  author    = {Sadegh Dalvandi and
               Brijesh Dongol},
  title     = {Verifying C11-Style Weak Memory Libraries via Refinement},
  journal   = {CoRR},
  volume    = {abs/2108.06944},
  year      = {2021},
  url       = {https://arxiv.org/abs/2108.06944},
  eprinttype = {arXiv},
  eprint    = {2108.06944},
  timestamp = {Fri, 20 Aug 2021 13:55:54 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2108-06944.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Weak-mem logics
@inproceedings{vafeaidis+:rsl-oopsla13,
  author    = {Viktor Vafeiadis and
               Chinmay Narayan},
  title     = {Relaxed separation logic: a program logic for {C11} concurrency},
  booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} International Conference on
               Object Oriented Programming Systems Languages {\&} Applications,
               {OOPSLA} 2013, part of {SPLASH} 2013, Indianapolis, IN, USA, October
               26-31, 2013},
  pages     = {867--884},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2509136.2509532},
  doi       = {10.1145/2509136.2509532},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/oopsla/VafeiadisN13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{gps,
  author    = {Aaron Turon and
               Viktor Vafeiadis and
               Derek Dreyer},
  title     = {{GPS:} navigating weak memory with ghosts, protocols, and separation},
  booktitle = {Proceedings of the 2014 {ACM} International Conference on Object Oriented
               Programming Systems Languages {\&} Applications, {OOPSLA} 2014,
               part of {SPLASH} 2014, Portland, OR, USA, October 20-24, 2014},
  pages     = {691--707},
  publisher = {{ACM}},
  year      = {2014},
  url       = {https://doi.org/10.1145/2660193.2660243},
  doi       = {10.1145/2660193.2660243},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/oopsla/TuronVD14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{doko+:fsl-vmcai16,
  author    = {Marko Doko and
               Viktor Vafeiadis},
  title     = {A Program Logic for {C11} Memory Fences},
  booktitle = {Verification, Model Checking, and Abstract Interpretation - 17th International
               Conference, {VMCAI} 2016, St. Petersburg, FL, USA, January 17-19,
               2016. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9583},
  pages     = {413--430},
  publisher = {Springer},
  year      = {2016},
  url       = {https://doi.org/10.1007/978-3-662-49122-5\_20},
  doi       = {10.1007/978-3-662-49122-5\_20},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/conf/vmcai/DokoV16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{doko+:fsl++-esop17,
  author    = {Marko Doko and
               Viktor Vafeiadis},
  title     = {Tackling Real-Life Relaxed Concurrency with {FSL++}},
  booktitle = {Programming Languages and Systems - 26th European Symposium on Programming,
               {ESOP} 2017, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2017, Uppsala, Sweden, April 22-29,
               2017, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {10201},
  pages     = {448--475},
  publisher = {Springer},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-662-54434-1\_17},
  doi       = {10.1007/978-3-662-54434-1\_17},
  timestamp = {Fri, 27 Dec 2019 21:27:18 +0100},
  biburl    = {https://dblp.org/rec/conf/esop/DokoV17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{igps,
  author    = {Jan{-}Oliver Kaiser and
               Hoang{-}Hai Dang and
               Derek Dreyer and
               Ori Lahav and
               Viktor Vafeiadis},
  title     = {Strong Logic for Weak Memory: Reasoning About Release-Acquire Consistency
               in {Iris}},
  booktitle = {31st European Conference on Object-Oriented Programming, {ECOOP} 2017,
               June 19-23, 2017, Barcelona, Spain},
  series    = {LIPIcs},
  volume    = {74},
  pages     = {17:1--17:29},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2017},
  url       = {https://doi.org/10.4230/LIPIcs.ECOOP.2017.17},
  doi       = {10.4230/LIPIcs.ECOOP.2017.17},
  timestamp = {Tue, 11 Feb 2020 15:52:14 +0100},
  biburl    = {https://dblp.org/rec/conf/ecoop/KaiserDDLV17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{svendsen+:promising-esop18,
  author    = {Kasper Svendsen and
               Jean Pichon{-}Pharabod and
               Marko Doko and
               Ori Lahav and
               Viktor Vafeiadis},
  title     = {A Separation Logic for a Promising Semantics},
  booktitle = {Programming Languages and Systems - 27th European Symposium on Programming,
               {ESOP} 2018, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2018, Thessaloniki, Greece, April
               14-20, 2018, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {10801},
  pages     = {357--384},
  publisher = {Springer},
  year      = {2018},
  url       = {https://doi.org/10.1007/978-3-319-89884-1\_13},
  doi       = {10.1007/978-3-319-89884-1\_13},
  timestamp = {Fri, 31 Jan 2020 21:32:28 +0100},
  biburl    = {https://dblp.org/rec/conf/esop/SvendsenPDLV18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{he+:gps+-pp18,
  author    = {Mengda He and
               Viktor Vafeiadis and
               Shengchao Qin and
               Jo{\~{a}}o F. Ferreira},
  title     = {{GPS+}: Reasoning About Fences and Relaxed Atomics},
  journal   = {Int. J. Parallel Program.},
  volume    = {46},
  number    = {6},
  pages     = {1157--1183},
  year      = {2018},
  url       = {https://doi.org/10.1007/s10766-017-0518-x},
  doi       = {10.1007/s10766-017-0518-x},
  timestamp = {Wed, 01 Apr 2020 08:49:36 +0200},
  biburl    = {https://dblp.org/rec/journals/ijpp/HeVQF18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{rustbelt-relaxed,
  author    = {Hoang{-}Hai Dang and
               Jacques{-}Henri Jourdan and
               Jan{-}Oliver Kaiser and
               Derek Dreyer},
  title     = {{RustBelt} meets relaxed memory},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {4},
  number    = {{POPL}},
  pages     = {34:1--34:29},
  year      = {2020},
  url       = {https://doi.org/10.1145/3371102},
  doi       = {10.1145/3371102},
  timestamp = {Wed, 17 Feb 2021 08:54:07 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/DangJKD20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{tassarotti+:rcu-pldi15,
  author    = {Joseph Tassarotti and
               Derek Dreyer and
               Viktor Vafeiadis},
  title     = {Verifying read-copy-update in a logic for weak memory},
  booktitle = {Proceedings of the 36th {ACM} {SIGPLAN} Conference on Programming
               Language Design and Implementation, Portland, OR, USA, June 15-17,
               2015},
  pages     = {110--120},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2737924.2737992},
  doi       = {10.1145/2737924.2737992},
  timestamp = {Wed, 23 Jun 2021 16:58:51 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/TassarottiDV15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Refinement

@inproceedings{turon+:caresl-ifcp13,
  author    = {Aaron Turon and
               Derek Dreyer and
               Lars Birkedal},
  title     = {Unifying refinement and hoare-style reasoning in a logic for higher-order
               concurrency},
  booktitle = {{ACM} {SIGPLAN} International Conference on Functional Programming,
               ICFP'13, Boston, MA, {USA} - September 25 - 27, 2013},
  pages     = {377--390},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2500365.2500600},
  doi       = {10.1145/2500365.2500600},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/icfp/TuronDB13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{frumin+:ReLoC-lics18,
  author    = {Dan Frumin and
               Robbert Krebbers and
               Lars Birkedal},
  title     = {{ReLoC}: {A} Mechanised Relational Logic for Fine-Grained Concurrency},
  booktitle = {Proceedings of the 33rd Annual {ACM/IEEE} Symposium on Logic in Computer
               Science, {LICS} 2018, Oxford, UK, July 09-12, 2018},
  pages     = {442--451},
  publisher = {{ACM}},
  year      = {2018},
  url       = {https://doi.org/10.1145/3209108.3209174},
  doi       = {10.1145/3209108.3209174},
  timestamp = {Sat, 05 Sep 2020 17:56:15 +0200},
  biburl    = {https://dblp.org/rec/conf/lics/FruminKB18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{KJ+:rel-popl17,
  author    = {Morten Krogh{-}Jespersen and
               Kasper Svendsen and
               Lars Birkedal},
  title     = {A relational model of types-and-effects in higher-order concurrent
               separation logic},
  booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of
               Programming Languages, {POPL} 2017, Paris, France, January 18-20,
               2017},
  pages     = {218--231},
  publisher = {{ACM}},
  year      = {2017},
  url       = {https://doi.org/10.1145/3009837.3009877},
  doi       = {10.1145/3009837.3009877},
  timestamp = {Mon, 14 Jun 2021 15:39:36 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/Krogh-Jespersen17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{dRP+:TaDA-ecoop14,
  author    = {Pedro da Rocha Pinto and
               Thomas Dinsdale{-}Young and
               Philippa Gardner},
  title     = {{TaDA}: {A} Logic for Time and Data Abstraction},
  booktitle = {{ECOOP} 2014 - Object-Oriented Programming - 28th European Conference,
               Uppsala, Sweden, July 28 - August 1, 2014. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {8586},
  pages     = {207--231},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-662-44202-9\_9},
  doi       = {10.1007/978-3-662-44202-9\_9},
  timestamp = {Tue, 14 May 2019 10:00:54 +0200},
  biburl    = {https://dblp.org/rec/conf/ecoop/PintoDG14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{svendsen+:iCAP-esop14,
  author    = {Kasper Svendsen and
               Lars Birkedal},
  title     = {Impredicative Concurrent Abstract Predicates},
  booktitle = {Programming Languages and Systems - 23rd European Symposium on Programming,
               {ESOP} 2014, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2014, Grenoble, France, April 5-13,
               2014, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {8410},
  pages     = {149--168},
  publisher = {Springer},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-642-54833-8\_9},
  doi       = {10.1007/978-3-642-54833-8\_9},
  timestamp = {Thu, 14 Oct 2021 10:31:33 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/SvendsenB14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{liang+:LPs-pldi13,
  author    = {Hongjin Liang and
               Xinyu Feng},
  title     = {Modular verification of linearizability with non-fixed linearization
               points},
  booktitle = {{ACM} {SIGPLAN} Conference on Programming Language Design and Implementation,
               {PLDI} '13, Seattle, WA, USA, June 16-19, 2013},
  pages     = {459--470},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2491956.2462189},
  doi       = {10.1145/2491956.2462189},
  timestamp = {Fri, 30 Nov 2018 12:24:24 +0100},
  biburl    = {https://dblp.org/rec/conf/pldi/LiangF13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{gotsman+:lin-own-concur12,
  author    = {Alexey Gotsman and
               Hongseok Yang},
  title     = {Linearizability with Ownership Transfer},
  booktitle = {{CONCUR} 2012 - Concurrency Theory - 23rd International Conference,
               {CONCUR} 2012, Newcastle upon Tyne, UK, September 4-7, 2012. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {7454},
  pages     = {256--271},
  publisher = {Springer},
  year      = {2012},
  url       = {https://doi.org/10.1007/978-3-642-32940-1\_19},
  doi       = {10.1007/978-3-642-32940-1\_19},
  timestamp = {Tue, 14 May 2019 10:00:43 +0200},
  biburl    = {https://dblp.org/rec/conf/concur/GotsmanY12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{mevel+:cosmo-icfp20,
  author    = {Glen M{\'{e}}vel and
               Jacques{-}Henri Jourdan and
               Fran{\c{c}}ois Pottier},
  title     = {Cosmo: a concurrent separation logic for multicore OCaml},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {4},
  number    = {{ICFP}},
  pages     = {96:1--96:29},
  year      = {2020},
  url       = {https://doi.org/10.1145/3408978},
  doi       = {10.1145/3408978},
  timestamp = {Wed, 17 Feb 2021 08:54:03 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/MevelJP20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{mevel+:cosmo-icfp21,
  author    = {Glen M{\'{e}}vel and
               Jacques{-}Henri Jourdan},
  title     = {Formal verification of a concurrent bounded queue in a weak memory
               model},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {5},
  number    = {{ICFP}},
  pages     = {1--29},
  year      = {2021},
  url       = {https://doi.org/10.1145/3473571},
  doi       = {10.1145/3473571},
  timestamp = {Mon, 30 Aug 2021 17:42:44 +0200},
  biburl    = {https://dblp.org/rec/journals/pacmpl/MevelJ21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{boyland2003checking,
  title={Checking interference with fractional permissions},
  author={Boyland, John},
  booktitle={SAS},
  year={2003},
  series    = {LNCS},
  doi= {10.1007/3-540-44898-5_4}
}

@article{FILIPOVIC20104379,
title = {Abstraction for concurrent objects},
journal = {Theoretical Computer Science},
volume = {411},
number = {51},
pages = {4379-4398},
year = {2010},
note = {European Symposium on Programming 2009},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2010.09.021},
url = {https://www.sciencedirect.com/science/article/pii/S0304397510005001},
author = {Ivana Filipović and Peter O’Hearn and Noam Rinetzky and Hongseok Yang},
keywords = {Linearizability, Sequential consistency, Observational equivalence, Observational refinement},
abstract = {Concurrent data structures are usually designed to satisfy correctness conditions such as sequential consistency or linearizability. In this paper, we consider the following fundamental question: What guarantees are provided by these conditions for client programs? We formally show that these conditions can be characterized in terms of observational refinement. Our study also provides a new understanding of sequential consistency and linearizability in terms of abstraction of dependency between computation steps of client programs.}
}

@inproceedings{michael-scott-queue:podc-96,
  author    = {Maged M. Michael and
               Michael L. Scott},
  title     = {Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue
               Algorithms},
  booktitle = {Proceedings of the Fifteenth Annual {ACM} Symposium on Principles
               of Distributed Computing, Philadelphia, Pennsylvania, USA, May 23-26,
               1996},
  pages     = {267--275},
  publisher = {{ACM}},
  year      = {1996},
  url       = {https://doi.org/10.1145/248052.248106},
  doi       = {10.1145/248052.248106},
  timestamp = {Wed, 14 Nov 2018 10:51:56 +0100},
  biburl    = {https://dblp.org/rec/conf/podc/MichaelS96.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{Treiber:86,
  title={Systems Programming: Coping with Parallelism},
  author={Treiber, R.K.},
  series={Research Report RJ},
  url={https://books.google.lu/books?id=YQg3HAAACAAJ},
  year={1986},
  publisher={International Business Machines Incorporated, Thomas J. Watson Research Center}
}

@article{scherer+:exchanger,
  title={A scalable elimination-based exchange channel},
  author={Scherer, William and Lea, Doug and Scott, Michael},
  year={2005}
}


@inproceedings{iris,
  author    = {Ralf Jung and
               David Swasey and
               Filip Sieczkowski and
               Kasper Svendsen and
               Aaron Turon and
               Lars Birkedal and
               Derek Dreyer},
  title     = {Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent
               Reasoning},
  booktitle = {Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
               Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
               15-17, 2015},
  pages     = {637--650},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2676726.2676980},
  doi       = {10.1145/2676726.2676980},
  timestamp = {Thu, 14 Oct 2021 09:53:20 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/JungSSSTBD15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{iris2,
  author    = {Ralf Jung and
               Robbert Krebbers and
               Lars Birkedal and
               Derek Dreyer},
  title     = {Higher-order ghost state},
  booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2016, Nara, Japan, September 18-22,
               2016},
  pages     = {256--269},
  publisher = {{ACM}},
  year      = {2016},
  url       = {https://doi.org/10.1145/2951913.2951943},
  doi       = {10.1145/2951913.2951943},
  timestamp = {Wed, 23 Jun 2021 15:34:31 +0200},
  biburl    = {https://dblp.org/rec/conf/icfp/0002KBD16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{iris3,
  author    = {Robbert Krebbers and
               Ralf Jung and
               Ales Bizjak and
               Jacques{-}Henri Jourdan and
               Derek Dreyer and
               Lars Birkedal},
  title     = {The Essence of Higher-Order Concurrent Separation Logic},
  booktitle = {Programming Languages and Systems - 26th European Symposium on Programming,
               {ESOP} 2017, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2017, Uppsala, Sweden, April 22-29,
               2017, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {10201},
  pages     = {696--723},
  publisher = {Springer},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-662-54434-1\_26},
  doi       = {10.1007/978-3-662-54434-1\_26},
  timestamp = {Tue, 14 May 2019 10:00:41 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/Krebbers0BJDB17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{iris-ground-up,
  author    = {Ralf Jung and
               Robbert Krebbers and
               Jacques{-}Henri Jourdan and
               Ales Bizjak and
               Lars Birkedal and
               Derek Dreyer},
  title     = {Iris from the ground up: {A} modular foundation for higher-order concurrent
               separation logic},
  journal   = {J. Funct. Program.},
  volume    = {28},
  pages     = {e20},
  year      = {2018},
  url       = {https://doi.org/10.1017/S0956796818000151},
  doi       = {10.1017/S0956796818000151},
  timestamp = {Tue, 15 Jan 2019 17:06:15 +0100},
  biburl    = {https://dblp.org/rec/journals/jfp/JungKJBBD18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{hendler+:elim-spaa04,
  author    = {Danny Hendler and
               Nir Shavit and
               Lena Yerushalmi},
  title     = {A scalable lock-free stack algorithm},
  booktitle = {{SPAA} 2004: Proceedings of the Sixteenth Annual {ACM} Symposium on
               Parallelism in Algorithms and Architectures, June 27-30, 2004, Barcelona,
               Spain},
  pages     = {206--215},
  publisher = {{ACM}},
  year      = {2004},
  url       = {https://doi.org/10.1145/1007912.1007944},
  doi       = {10.1145/1007912.1007944},
  timestamp = {Wed, 21 Nov 2018 11:11:51 +0100},
  biburl    = {https://dblp.org/rec/conf/spaa/HendlerSY04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{steinke+:views-04,
  author    = {Robert C. Steinke and
               Gary J. Nutt},
  title     = {A unified theory of shared memory consistency},
  journal   = {J. {ACM}},
  volume    = {51},
  number    = {5},
  pages     = {800--849},
  year      = {2004},
  url       = {https://doi.org/10.1145/1017460.1017464},
  doi       = {10.1145/1017460.1017464},
  timestamp = {Wed, 14 Nov 2018 10:35:24 +0100},
  biburl    = {https://dblp.org/rec/journals/jacm/SteinkeN04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{lahav+:sra-popl16,
  author    = {Ori Lahav and
               Nick Giannarakis and
               Viktor Vafeiadis},
  title     = {Taming release-acquire consistency},
  booktitle = {Proceedings of the 43rd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
               Principles of Programming Languages, {POPL} 2016, St. Petersburg,
               FL, USA, January 20 - 22, 2016},
  pages     = {649--662},
  publisher = {{ACM}},
  year      = {2016},
  url       = {https://doi.org/10.1145/2837614.2837643},
  doi       = {10.1145/2837614.2837643},
  timestamp = {Wed, 23 Jun 2021 15:34:31 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/LahavGV16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{oehman+:visibility-popl22,
  title={Visibility Reasoning for Concurrent Snapshot Algorithms}, 
  author={Joakim \"Ohman and Aleksandar Nanevski},
  year={2022},
  booktitle = {POPL},
}

% Work stealing-queue
@inproceedings{chase-lev:dequeue-spaa05,
  author    = {David Chase and
               Yossi Lev},
  title     = {Dynamic circular work-stealing deque},
  booktitle = {{SPAA} 2005: Proceedings of the 17th Annual {ACM} Symposium on Parallelism
               in Algorithms and Architectures, July 18-20, 2005, Las Vegas, Nevada,
               {USA}},
  pages     = {21--28},
  publisher = {{ACM}},
  year      = {2005},
  url       = {https://doi.org/10.1145/1073970.1073974},
  doi       = {10.1145/1073970.1073974},
  timestamp = {Wed, 21 Nov 2018 11:12:26 +0100},
  biburl    = {https://dblp.org/rec/conf/spaa/ChaseL05.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{le+:dequeue-ppopp13,
  author    = {Nhat Minh L{\^{e}} and
               Antoniu Pop and
               Albert Cohen and
               Francesco Zappa Nardelli},
  title     = {Correct and efficient work-stealing for weak memory models},
  booktitle = {{ACM} {SIGPLAN} Symposium on Principles and Practice of Parallel Programming,
               PPoPP '13, Shenzhen, China, February 23-27, 2013},
  pages     = {69--80},
  publisher = {{ACM}},
  year      = {2013},
  url       = {https://doi.org/10.1145/2442516.2442524},
  doi       = {10.1145/2442516.2442524},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/ppopp/LePCN13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% memory reclamation
@article{maged:hazptr,
  author     = {Michael, Maged M.},
  title      = {Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects},
  year       = {2004},
  issue_date = {June 2004},
  publisher  = {IEEE Press},
  volume     = {15},
  number     = {6},
  issn       = {1045-9219},
  url        = {https://doi.org/10.1109/TPDS.2004.8},
  doi        = {10.1109/TPDS.2004.8},
  journal    = {IEEE Trans. Parallel Distrib. Syst.},
  month      = jun,
  pages      = {491–504},
  numpages   = {14},
  keywords   = {dynamic data structures., Lock-free, memory management, multiprogramming, concurrent programming, synchronization, 65}
}

@phdthesis{fraser:ebr,
  author    = {Keir Fraser},
  title     = {Practical lock-freedom},
  school    = {University of Cambridge},
  year      = {2004},
}

@inproceedings{kang+jung:pebr-pldi20,
  author    = {Jeehoon Kang and
               Jaehwang Jung},
  title     = {A marriage of pointer- and epoch-based reclamation},
  booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} International Conference on
               Programming Language Design and Implementation, {PLDI} 2020, London,
               UK, June 15-20, 2020},
  pages     = {314--328},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3385412.3385978},
  doi       = {10.1145/3385412.3385978},
  timestamp = {Tue, 09 Jun 2020 13:52:54 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/KangJ20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% crossbeam
@misc{www:crossbeam,
  title = {Crossbeam: Tools for concurrent programming in Rust},
  note = {Available at \url{https://github.com/crossbeam-rs/crossbeam}},
  year = {2021},
}

@misc{coqappendix,
  title = {Accompanying supplementary materials and Coq development of Compass (anonymized and submitted with the paper)},
  year = {2021}
}

@article{Sergey:2016,
  author    = {Anton Podkopaev and
               Ilya Sergey and
               Aleksandar Nanevski},
  title     = {Operational Aspects of {C/C++} Concurrency},
  journal   = {CoRR},
  volume    = {abs/1606.01400},
  year      = {2016},
  url       = {http://arxiv.org/abs/1606.01400},
  timestamp = {Fri, 01 Jul 2016 17:39:49 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/PodkopaevSN16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{cerberus,
  author    = {Stella Lau and
               Victor B. F. Gomes and
               Kayvan Memarian and
               Jean Pichon{-}Pharabod and
               Peter Sewell},
  editor    = {Isil Dillig and
               Serdar Tasiran},
  title     = {Cerberus-{BMC}: {A} Principled Reference Semantics and Exploration Tool
               for Concurrent and Sequential {C}},
  booktitle = {Computer Aided Verification - 31st International Conference, {CAV}
               2019, New York City, NY, USA, July 15-18, 2019, Proceedings, Part
               {I}},
  series    = {Lecture Notes in Computer Science},
  volume    = {11561},
  pages     = {387--397},
  publisher = {Springer},
  year      = {2019},
  url       = {https://doi.org/10.1007/978-3-030-25540-4\_22},
  doi       = {10.1007/978-3-030-25540-4\_22},
  timestamp = {Fri, 31 Jan 2020 21:32:18 +0100},
  biburl    = {https://dblp.org/rec/conf/cav/LauGMPS19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{vst,
  author    = {Andrew W. Appel and Robert Dockins and Aquinas Hobor and 
          Lennart Beringer and Josiah Dodds and Gordon Stewart and 
          Sandrine Blazy and Xavier Leroy},
  title     = {Program Logics for Certified Compilers},
  publisher = {Cambridge University Press},
  year      = {2014},
  url       = {http://www.cambridge.org/de/academic/subjects/computer-science/programming-languages-and-applied-logic/program-logics-certified-compilers?format=HB},
  isbn      = {978-1-10-704801-0},
  biburl    = {https://dblp.org/rec/bib/books/daglib/0034962},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{templates,
  author    = {Siddharth Krishna and
               Nisarg Patel and
               Dennis E. Shasha and
               Thomas Wies},
  editor    = {Alastair F. Donaldson and
               Emina Torlak},
  title     = {Verifying concurrent search structure templates},
  booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} International Conference on
               Programming Language Design and Implementation, {PLDI} 2020, London,
               UK, June 15-20, 2020},
  pages     = {181--196},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3385412.3386029},
  doi       = {10.1145/3385412.3386029},
  timestamp = {Wed, 22 Sep 2021 15:48:24 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/KrishnaPSW20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{vst-floyd,
  author    = {Qinxiang Cao and
               Lennart Beringer and
               Samuel Gruetter and
               Josiah Dodds and
               Andrew W. Appel},
  title     = {{VST-Floyd}: {A} Separation Logic Tool to Verify Correctness of {C}
               Programs},
  journal   = {J. Autom. Reasoning},
  volume    = {61},
  number    = {1-4},
  pages     = {367--422},
  year      = {2018},
  url       = {https://doi.org/10.1007/s10817-018-9457-5},
  doi       = {10.1007/s10817-018-9457-5},
  timestamp = {Fri, 01 Jun 2018 14:55:08 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/jar/CaoBGDA18},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{vst-hmac,
  author    = {Lennart Beringer and
               Adam Petcher and
               Katherine Q. Ye and
               Andrew W. Appel},
  editor    = {Jaeyeon Jung and
               Thorsten Holz},
  title     = {Verified Correctness and Security of {OpenSSL} {HMAC}},
  booktitle = {24th {USENIX} Security Symposium, {USENIX} Security 15, Washington,
               D.C., USA, August 12-14, 2015},
  pages     = {207--221},
  publisher = {{USENIX} Association},
  year      = {2015},
  url       = {https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/beringer},
  timestamp = {Mon, 01 Feb 2021 08:43:09 +0100},
  biburl    = {https://dblp.org/rec/conf/uss/BeringerPYA15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{mailbox,
 author = {Mansky, William and Appel, Andrew W. and Nogin, Aleksey},
 title = {A Verified Messaging System},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {October 2017},
 volume = {1},
 number = {OOPSLA},
 month = oct,
 year = {2017},
 issn = {2475-1421},
 pages = {87:1--87:28},
 articleno = {87},
 numpages = {28},
 url = {http://doi.acm.org/10.1145/3133911},
 doi = {10.1145/3133911},
 acmid = {3133911},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {concurrent separation logic, shared-memory communication, shared-memory concurrency},
}

@inproceedings{oracle-semantics,
 author = {Hobor, Aquinas and Appel, Andrew W. and Nardelli, Francesco Zappa},
 title = {Oracle Semantics for Concurrent Separation Logic},
 booktitle = {Proceedings of the Theory and Practice of Software, 17th European Conference on Programming Languages and Systems},
 series = {ESOP'08/ETAPS'08},
 year = {2008},
 isbn = {3-540-78738-0, 978-3-540-78738-9},
 location = {Budapest, Hungary},
 pages = {353--367},
 numpages = {15},
 url = {http://dl.acm.org/citation.cfm?id=1792878.1792914},
 acmid = {1792914},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
} 

@inproceedings{fcsl,
author = {Sergey, Ilya and Nanevski, Aleksandar and Banerjee, Anindya},
title = {Mechanized Verification of Fine-Grained Concurrent Programs},
year = {2015},
isbn = {9781450334686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2737924.2737964},
doi = {10.1145/2737924.2737964},
abstract = { Efficient concurrent programs and data structures rarely employ coarse-grained synchronization mechanisms (i.e., locks); instead, they implement custom synchronization patterns via fine-grained primitives, such as compare-and-swap. Due to sophisticated interference scenarios between threads, reasoning about such programs is challenging and error-prone, and can benefit from mechanization. In this paper, we present the first completely formalized framework for mechanized verification of full functional correctness of fine-grained concurrent programs. Our tool is based on the recently proposed program logic FCSL. It is implemented as an embedded DSL in the dependently-typed language of the Coq proof assistant, and is powerful enough to reason about programming features such as higher-order functions and local thread spawning. By incorporating a uniform concurrency model, based on state-transition systems and partial commutative monoids, FCSL makes it possible to build proofs about concurrent libraries in a thread-local, compositional way, thus facilitating scalability and reuse: libraries are verified just once, and their specifications are used ubiquitously in client-side reasoning. We illustrate the proof layout in FCSL by example, outline its infrastructure, and report on our experience of using FCSL to verify a number of concurrent algorithms and data structures. },
booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {77–87},
numpages = {11},
keywords = {mechanized proofs, dependent types, separation logic, Compositional program verification, concurrency},
location = {Portland, OR, USA},
series = {PLDI '15}
}

@techreport{cpm,
  author      = " Cuellar, Santiago and Giannarakis, Nick and Madiot, Jean-Marie and Mansky, William and Beringer, Lennart and Cao, Qinxiang and Appel, Andrew ",
  title       = "Compiler Correctness for Concurrency: from concurrent separation logic to shared-memory assembly language",
  institution = "Princeton University",
  year        = "2020"
}

@inproceedings{masstree,
 author = {Mao, Yandong and Kohler, Eddie and Morris, Robert Tappan},
 title = {Cache Craftiness for Fast Multicore Key-value Storage},
 booktitle = {Proceedings of the 7th ACM European Conference on Computer Systems},
 series = {EuroSys '12},
 year = {2012},
 isbn = {978-1-4503-1223-3},
 location = {Bern, Switzerland},
 pages = {183--196},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2168836.2168855},
 doi = {10.1145/2168836.2168855},
 acmid = {2168855},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {in-memory, key-value, multicore, persistent},
} 

@inproceedings{wormhole,
author = {Wu, Xingbo and Ni, Fan and Jiang, Song},
title = {Wormhole: A Fast Ordered Index for In-Memory Data Management},
year = {2019},
isbn = {9781450362818},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3302424.3303955},
doi = {10.1145/3302424.3303955},
abstract = {In-memory data management systems, such as key-value stores, have become an essential infrastructure in today's big-data processing and cloud computing. They rely on efficient index structures to access data. While unordered indexes, such as hash tables, can perform point search with O(1) time, they cannot be used in many scenarios where range queries must be supported. Many ordered indexes, such as B+ tree and skip list, have a O(log N) lookup cost, where N is number of keys in an index. For an ordered index hosting billions of keys, it may take more than 30 key-comparisons in a lookup, which is an order of magnitude more expensive than that on a hash table. With availability of large memory and fast network in today's data centers, this O(log N) time is taking a heavy toll on applications that rely on ordered indexes.In this paper we introduce a new ordered index structure, named Wormhole, that takes O(log L) worst-case time for looking up a key with a length of L. The low cost is achieved by simultaneously leveraging strengths of three indexing structures, namely hash table, prefix tree, and B+ tree, to orchestrate a single fast ordered index. Wormhole's range operations can be performed by a linear scan of a list after an initial lookup. This improvement of access efficiency does not come at a price of compromised space efficiency. Instead, Wormhole's index space is comparable to those of B+ tree and skip list. Experiment results show that Wormhole outperforms skip list, B+ tree, ART, and Masstree by up to 8.4x, 4.9x, 4.3x, and 6.6x in terms of key lookup throughput, respectively.},
booktitle = {Proceedings of the Fourteenth EuroSys Conference 2019},
articleno = {18},
numpages = {16},
location = {Dresden, Germany},
series = {EuroSys '19}
}

@inproceedings{reloc-mpmc,
author = {Vindum, Simon Friis and Frumin, Dan and Birkedal, Lars},
title = {Mechanized Verification of a Fine-Grained Concurrent Queue from {Meta}’s {Folly} Library},
year = {2022},
isbn = {9781450391825},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3497775.3503689},
doi = {10.1145/3497775.3503689},
abstract = {We present the first formal specification and verification of the fine-grained concurrent multi-producer-multi-consumer queue algorithm from Meta’s C++ library Folly of core infrastructure components. The queue is highly optimized, practical, and used by Meta in production where it scales to thousands of consumer and producer threads. We present an implementation of the algorithm in an ML-like language and formally prove that it is a contextual refinement of a simple coarse-grained queue (a property that implies that the MPMC queue is linearizable). We use the ReLoC relational logic and the Iris program logic to carry out the proof and to mechanize it in the Coq proof assistant. The MPMC queue is implemented using three modules, and our proof is similarly modular. By using ReLoC and Iris’s support for modular reasoning we verify each module in isolation and compose these together. A key challenge of the MPMC queue is that it has a so-called external linearization point, which ReLoC has no support for reasoning about. Thus we extend ReLoC, both on paper and in Coq, with novel support for reasoning about external linearization points.},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {100–115},
numpages = {16},
keywords = {concurrent data structures, Coq, separation logic},
location = {Philadelphia, PA, USA},
series = {CPP 2022}
}

@InProceedings{vst-external,
author="Mansky, William
and Honor{\'e}, Wolf
and Appel, Andrew W.",
editor="M{\"u}ller, Peter",
title="Connecting Higher-Order Separation Logic to a First-Order Outside World",
booktitle="Programming Languages and Systems",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="428--455",
abstract="Separation logic is a useful tool for proving the correctness of programs that manipulate memory, especially when the model of memory includes higher-order state: Step-indexing, predicates in the heap, and higher-order ghost state have been used to reason about function pointers, data structure invariants, and complex concurrency patterns. On the other hand, the behavior of system features (e.g., operating systems) and the external world (e.g., communication between components) is usually specified using first-order formalisms. In principle, the soundness theorem of a separation logic is its interface with first-order theorems, but the soundness theorem may implicitly make assumptions about how other components are specified, limiting its use. In this paper, we show how to extend the higher-order separation logic of the Verified Software Toolchain to interface with a first-order verified operating system, in this case CertiKOS, that mediates its interaction with the outside world. The resulting system allows us to prove the correctness of C programs in separation logic based on the semantics of system calls implemented in CertiKOS. It also demonstrates that the combination of interaction trees + CompCert memories serves well as a lingua franca to interface and compose two quite different styles of program verification.",
isbn="978-3-030-44914-8"
}

@InProceedings{BeringerVSU2020,
author="Beringer, Lennart",
editor="Yoshida, Nobuko",
title="Verified Software Units",
booktitle="Programming Languages and Systems",
year="2021",
publisher="Springer International Publishing",
address="Cham",
pages="118--147",
abstract="Modularity - the partitioning of software into units of functionality that interact with each other via interfaces - has been the mainstay of software development for half a century. In case of the C language, the main mechanism for modularity is the compilation unit / header file abstraction. This paper complements programmatic modularity for C with modularity idioms for specification and verification in the context of Verifiable C, an expressive separation logic for CompCert Clight. Technical innovations include (i) abstract predicate declarations -- existential packages that combine Parkinson {\&} Bierman's abstract predicates with their client-visible reasoning principles; (ii) residual predicates, which help enforcing data abstraction in callback-rich code; and (iii) an application to pure (Smalltalk-style) objects that connects code verification to model-level reasoning about features such as subtyping, self, inheritance, and late binding. We introduce our techniques using concrete example modules that have all been verified using the Coq proof assistant and combine to fully linked verified programs using a novel, abstraction-respecting component composition rule for Verifiable C.",
isbn="978-3-030-72019-3"
}


@String{pub-ISO                 = "International Organization for
                                  Standardization"}
@String{pub-ISO:adr             = "Geneva, Switzerland"}

@String{ack-nhfb = "Nelson H. F. Beebe,
                    University of Utah,
                    Department of Mathematics, 110 LCB,
                    155 S 1400 E RM 233,
                    Salt Lake City, UT 84112-0090, USA,
                    Tel: +1 801 581 5254,
                    FAX: +1 801 581 4148,
                    e-mail: \path|beebe@math.utah.edu|,
                            \path|beebe@acm.org|,
                            \path|beebe@computer.org| (Internet),
                    URL: \path|http://www.math.utah.edu/~beebe/|"}

@Book{c11,
  author =       "{ISO}",
  title =        "{ISO\slash IEC 9899:2011 Information technology ---
                 Programming languages --- C}",
  publisher =    pub-ISO,
  address =      pub-ISO:adr,
  pages =        "683 (est.)",
  day =          "8",
  month =        dec,
  year =         "2011",
  ISBN =         "????",
  ISBN-13 =      "????",
  LCCN =         "????",
  bibdate =      "Mon Dec 19 11:12:12 2011",
  bibsource =    "http://www.math.utah.edu/pub/tex/bib/isostd.bib;
                 http://www.math.utah.edu/pub/tex/bib/mathcw.bib",
  URL =          "http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=57853",
  acknowledgement = ack-nhfb,
  remark =       "Revises ISO/IEC 9899:1999, ISO/IEC 9899:1999/Cor
                 1:2001, ISO/IEC 9899:1999/Cor 2:2004, and ISO/IEC
                 9899:1999/Cor 3:2007.",
}

@misc{hashtable, title={The World's Simplest Lock-Free Hash Table}, url={https://preshing.com/20130605/the-worlds-simplest-lock-free-hash-table/}, howpublished = "\url{https://preshing.com/20130605/the-worlds-simplest-lock-free-hash-table/}", journal={Preshing on Programming}, author={Preshing, Jeff}, year={2013}, month={June}}

@misc{junction, title={Junction}, url={https://github.com/preshing/junction}, howpublished = "\url{https://github.com/preshing/junction}", journal={GitHub repository}, year={2018}}

@misc{liblfds, title={liblfds}, url={https://liblfds.org}, howpublished = "\url{https://liblfds.org}", year={2017}}

@misc{concurrencykit, title={Concurrency Kit}, url={https://github.com/concurrencykit/ck}, howpublished = "\url{https://github.com/concurrencykit/ck}", year={2023}}

@misc{folly, title={Folly}, url={https://github.com/facebook/folly}, howpublished = "\url{https://github.com/facebook/folly}", journal={GitHub repository}, year={2022}}

@article{compcert,
  author = {Xavier Leroy},
  title = {Formal verification of a realistic compiler},
  journal = {Communications of the ACM},
  year = 2009,
  volume = 52,
  number = 7,
  pages = {107--115},
  url = {http://gallium.inria.fr/~xleroy/publi/compcert-CACM.pdf},
  urlpublisher = {http://doi.acm.org/10.1145/1538788.1538814},
  hal = {http://hal.archives-ouvertes.fr/inria-00415861/},
  pubkind = {journal-int-mono},
  abstract = {This paper reports on the development and formal verification (proof
of semantic preservation) of CompCert, a compiler from Clight (a
large subset of the C programming language) to PowerPC assembly code,
using the Coq proof assistant both for programming the compiler and
for proving its correctness.  Such a verified compiler is useful in
the context of critical software and its formal verification: the
verification of the compiler guarantees that the safety properties
proved on the source code hold for the executable compiled code as
well.}
}

@software{coq,
author       = {The Coq Development Team},
  title        = {The {Coq} Proof Assistant},
  month        = Jun,
  year         = 2023,
  publisher    = {Zenodo},
  version      = {8.17},
  doi          = {10.5281/zenodo.8161141},
  url          = {https://doi.org/10.5281/zenodo.8161141}
}

@article{csl,
  author    = {Peter W. O'Hearn},
  title     = {Resources, concurrency, and local reasoning},
  journal   = {Theor. Comput. Sci.},
  volume    = {375},
  number    = {1-3},
  pages     = {271--307},
  year      = {2007},
  doi       = {10.1016/j.tcs.2006.12.035},
  timestamp = {Sun, 28 May 2017 13:20:02 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/tcs/OHearn07},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{aneris,
  author    = {Morten Krogh{-}Jespersen and
               Amin Timany and
               Marit Edna Ohlenbusch and
               Simon Oddershede Gregersen and
               Lars Birkedal},
  editor    = {Peter M{\"{u}}ller},
  title     = {Aneris: {A} Mechanised Logic for Modular Reasoning about Distributed
               Systems},
  booktitle = {Programming Languages and Systems - 29th European Symposium on Programming,
               {ESOP} 2020, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2020, Dublin, Ireland, April 25-30,
               2020, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {12075},
  pages     = {336--365},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-44914-8\_13},
  doi       = {10.1007/978-3-030-44914-8\_13},
  timestamp = {Fri, 14 May 2021 08:34:22 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/Krogh-Jespersen20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{rustbelt,
    author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
    title = {{RustBelt}: Securing the Foundations of the Rust Programming Language},
    year = {2017},
    issue_date = {January 2018},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {POPL},
    url = {https://doi.org/10.1145/3158154},
    doi = {10.1145/3158154},
    abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
    journal = {Proc. ACM Program. Lang.},
    month = {Dec},
    articleno = {66},
    numpages = {34},
    keywords = {logical relations, type systems, Rust, concurrency, separation logic}
    }

@article{iron,
author = {Bizjak, Ale\v{s} and Gratzer, Daniel and Krebbers, Robbert and Birkedal, Lars},
title = {Iron: Managing Obligations in Higher-Order Concurrent Separation Logic},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290378},
doi = {10.1145/3290378},
abstract = {Precise management of resources and the obligations they impose, such as the need to dispose of memory, close locks, and release file handles, is hard---especially in the presence of concurrency, when some resources are shared, and different threads operate on them concurrently. We present Iron, a novel higher-order concurrent separation logic that allows for precise reasoning about resources that are transferable among dynamically allocated threads. In particular, Iron can be used to show the correctness of challenging examples, where the reclamation of memory is delegated to a forked-off thread. We show soundness of Iron by means of a model of Iron, defined on top of the Iris base logic, and we use this model to prove that memory resources are accounted for precisely and not leaked. We have formalized all of the developments in the Coq proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = {Jan},
articleno = {65},
numpages = {30},
keywords = {resource management, Separation logic, concurrency}
}

@inproceedings{refinedc,
author = {Sammler, Michael and Lepigre, Rodolphe and Krebbers, Robbert and Memarian, Kayvan and Dreyer, Derek and Garg, Deepak},
title = {{RefinedC}: Automating the Foundational Verification of {C} Code with Refined Ownership Types},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454036},
doi = {10.1145/3453483.3454036},
abstract = {Given the central role that C continues to play in systems software, and the difficulty of writing safe and correct C code, it remains a grand challenge to develop effective formal methods for verifying C programs. In this paper, we propose a new approach to this problem: a type system we call RefinedC, which combines ownership types (for modular reasoning about shared state and concurrency) with refinement types (for encoding precise invariants on C data types and Hoare-style specifications for C functions). RefinedC is both automated (requiring minimal user intervention) and foundational (producing a proof of program correctness in Coq), while at the same time handling a range of low-level programming idioms such as pointer arithmetic. In particular, following the approach of RustBelt, the soundness of the RefinedC type system is justified semantically by interpretation into the Coq-based Iris framework for higher-order concurrent separation logic. However, the typing rules of RefinedC are also designed to be encodable in a new “separation logic programming” language we call Lithium. By restricting to a carefully chosen (yet expressive) fragment of separation logic, Lithium supports predictable, automatic, goal-directed proof search without backtracking. We demonstrate the effectiveness of RefinedC on a range of representative examples of C code.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {158–174},
numpages = {17},
keywords = {Iris, Coq, proof automation, C programming language, ownership types, separation logic, refinement types},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@article{iris-wasm,
  title={Iris-Wasm: Robust and modular verification of WebAssembly programs},
  author={Rao, Xiaojia and Georges, A{\"\i}na Linn and Legoupil, Maxime and Watt, Conrad and Pichon-Pharabod, Jean and Gardner, Philippa and Birkedal, Lars},
  journal={Proceedings of the ACM on Programming Languages},
  volume={7},
  number={PLDI},
  pages={1096--1120},
  year={2023},
  publisher={ACM New York, NY, USA}
}

@article{mosel,
author = {Krebbers, Robbert and Jourdan, Jacques-Henri and Jung, Ralf and Tassarotti, Joseph and Kaiser, Jan-Oliver and Timany, Amin and Chargu\'{e}raud, Arthur and Dreyer, Derek},
title = {{MoSeL}: A General, Extensible Modal Framework for Interactive Proofs in Separation Logic},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236772},
doi = {10.1145/3236772},
abstract = {A number of tools have been developed for carrying out separation-logic proofs mechanically using an interactive proof assistant. One of the most advanced such tools is the Iris Proof Mode (IPM) for Coq, which offers a rich set of tactics for making separation-logic proofs look and feel like ordinary Coq proofs. However, IPM is tied to a particular separation logic (namely, Iris), thus limiting its applicability.  In this paper, we propose MoSeL, a general and extensible Coq framework that brings the benefits of IPM to a much larger class of separation logics. Unlike IPM, MoSeL is applicable to both affine and linear separation logics (and combinations thereof), and provides generic tactics that can be easily extended to account for the bespoke connectives of the logics with which it is instantiated. To demonstrate the effectiveness of MoSeL, we have instantiated it to provide effective tactical support for interactive and semi-automated proofs in six very different separation logics.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {77},
numpages = {30},
keywords = {modal logic, interactive theorem proving, Coq proof assistant, logic of bunched implications, Separation logic}
}

    @inproceedings{compcert-backend,
    author = {Leroy, Xavier},
    title = {Formal Certification of a Compiler Back-End or: Programming a Compiler with a Proof Assistant},
    year = {2006},
    isbn = {1595930272},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1111037.1111042},
    doi = {10.1145/1111037.1111042},
    abstract = {This paper reports on the development and formal certification (proof of semantic preservation) of a compiler from Cminor (a C-like imperative language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a certified compiler is useful in the context of formal methods applied to the certification of critical software: the certification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
    booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    pages = {42–54},
    numpages = {13},
    keywords = {semantic preservation, compiler transformations and optimizations, the Coq theorem prover, program proof, certified compilation},
    location = {Charleston, South Carolina, USA},
    series = {POPL '06}
    }

 @misc{rehmeyer_2013, title={Voevodsky's Mathematical Revolution}, url={https://scilogs.spektrum.de/hlf/voevodskys-mathematical-revolution/}, journal={Scilogs}, publisher={Heidelberg Laureate Forum}, author={Rehmeyer, Julie}, year={2013}, month={Oct}} 
 
 @inproceedings{sasylf,
author = {Aldrich, Jonathan and Simmons, Robert J. and Shin, Key},
title = {{SASyLF}: An Educational Proof Assistant for Language Theory},
year = {2008},
isbn = {9781605580685},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411260.1411266},
doi = {10.1145/1411260.1411266},
abstract = {Teaching and learning formal programming language theory is hard, in part because it's easy to make mistakes and hard to find them. Proof assistants can help check proofs, but their learning curve is too steep to use in most classes, and is a barrier to researchers too.In this paper we present SASyLF, an LF-based proof assistant specialized to checking theorems about programming languages and logics. SASyLF has a simple design philosophy: language and logic syntax, semantics, and meta-theory should be written as closely as possible to the way it is done on paper. We describe how we designed the SASyLF syntax to be accessible to students learning type theory, and how students can understand its semantics directly in terms of the theory they are taught in class. SASyLF can express proofs typical of an introductory graduate type theory course. SASyLF proofs are generally very explicit, but its built-in support for variable binding provides substitution properties for free and avoids awkward variable encodings. We describe preliminary experience teaching with SASyLF.},
booktitle = {Proceedings of the 2008 International Workshop on Functional and Declarative Programming in Education},
pages = {31–40},
numpages = {10},
keywords = {proof assistant, education, logical framework, metatheory},
location = {Victoria, BC, Canada},
series = {FDPE '08}
}

@article{coblenz-2021,
  author    = {Michael Coblenz},
  title     = {Toward a Theory of Programming Language and Reasoning Assistant Design:
               Minimizing Cognitive Load},
  journal   = {CoRR},
  volume    = {abs/2110.03806},
  year      = {2021},
  url       = {https://arxiv.org/abs/2110.03806},
  eprinttype = {arXiv},
  eprint    = {2110.03806},
  timestamp = {Thu, 21 Oct 2021 16:20:08 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2110-03806.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{hazel,
  title = {Toward Semantic Foundations for Program Editors},
  author = {Cyrus Omar and Ian Voysey and Michael Hilton and Joshua Sunshine and Claire Le Goues and Jonathan Aldrich and Matthew A. Hammer},
  year = {2017},
  doi = {10.4230/LIPIcs.SNAPL.2017.11},
  url = {https://doi.org/10.4230/LIPIcs.SNAPL.2017.11},
  researchr = {https://researchr.org/publication/OmarVHSGAH17},
  cites = {0},
  citedby = {0},
  booktitle = {2nd Summit on Advances in Programming Languages, SNAPL 2017, May 7-10, 2017, Asilomar, CA, USA},
  editor = {Benjamin S. Lerner and Rastislav Bodík and Shriram Krishnamurthi},
  volume = {71},
  series = {LIPIcs},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  isbn = {978-3-95977-032-3},
}

@inproceedings{envision,
author = {Asenov, Dimitar and Hilliges, Otmar and M\"{u}ller, Peter},
title = {The Effect of Richer Visualizations on Code Comprehension},
year = {2016},
isbn = {9781450333627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2858036.2858372},
doi = {10.1145/2858036.2858372},
abstract = {Researchers often introduce visual tools to programming environments in order to facilitate program comprehension, reduce navigation times, and help developers answer difficult questions. Syntax highlighting is the main visual lens through which developers perceive their code, and yet its effects and the effects of richer code presentations on code comprehension have not been evaluated systematically. We present a rigorous user study comparing mainstream syntax highlighting to two visually-enhanced presentations of code. Our results show that: (1) richer code visualizations reduce the time necessary to answer questions about code features, and (2) contrary to the subjective perception of developers, richer code visualizations do not lead to visual overload. Based on our results we outline practical recommendations for tool designers.},
booktitle = {Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems},
pages = {5040–5045},
numpages = {6},
keywords = {programming, code editor, user study, syntax highlighting, visual programming, code comprehension},
location = {San Jose, California, USA},
series = {CHI '16}
}

@inproceedings{vega-insitu,
author = {Hoffswell, Jane and Satyanarayan, Arvind and Heer, Jeffrey},
title = {Augmenting Code with In Situ Visualizations to Aid Program Understanding},
year = {2018},
isbn = {9781450356206},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3173574.3174106},
doi = {10.1145/3173574.3174106},
abstract = {Programmers must draw explicit connections between their code and runtime state to properly assess the correctness of their programs. However, debugging tools often decouple the program state from the source code and require explicitly invoked views to bridge the rift between program editing and program understanding. To unobtrusively reveal runtime behavior during both normal execution and debugging, we contribute techniques for visualizing program variables directly within the source code. We describe a design space and placement criteria for embedded visualizations. We evaluate our in situ visualizations in an editor for the Vega visualization grammar. Compared to a baseline development environment, novice Vega users improve their overall task grade by about 2 points when using the in situ visualizations and exhibit significant positive effects on their self-reported speed and accuracy.},
booktitle = {Proceedings of the 2018 CHI Conference on Human Factors in Computing Systems},
pages = {1–12},
numpages = {12},
keywords = {debugging, visualization, program behavior, program understanding, code augmentation},
location = {Montreal QC, Canada},
series = {CHI '18}
}

@inproceedings{theseus,
author = {Lieber, Tom and Brandt, Joel R. and Miller, Rob C.},
title = {Addressing Misconceptions about Code with Always-on Programming Visualizations},
year = {2014},
isbn = {9781450324731},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2556288.2557409},
doi = {10.1145/2556288.2557409},
abstract = {We present Theseus, an IDE extension that visualizes run-time behavior within a JavaScript code editor. By displaying real-time information about how code actually behaves during execution, Theseus proactively addresses misconceptions by drawing attention to similarities and differences between the programmer's idea of what code does and what it actually does. To understand how programmers would respond to this kind of an always-on visualization, we ran a lab study with graduate students, and interviewed 9 professional programmers who were asked to use Theseus in their day-to-day work. We found that users quickly adopted strategies that are unique to always-on, real-time visualizations, and used the additional information to guide their navigation through their code.},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
pages = {2481–2490},
numpages = {10},
keywords = {code understanding, debugging, programming},
location = {Toronto, Ontario, Canada},
series = {CHI '14}
}

@inproceedings{online-python-tutor,
author = {Guo, Philip J.},
title = {{Online Python Tutor}: Embeddable Web-Based Program Visualization for {CS} Education},
year = {2013},
isbn = {9781450318686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2445196.2445368},
doi = {10.1145/2445196.2445368},
abstract = {This paper presents Online Python Tutor, a web-based program visualization tool for Python, which is becoming a popular language for teaching introductory CS courses. Using this tool, teachers and students can write Python programs directly in the web browser (without installing any plugins), step forwards and backwards through execution to view the run-time state of data structures, and share their program visualizations on the web. In the past three years, over 200,000 people have used Online Python Tutor to visualize their programs. In addition, instructors in a dozen universities such as UC Berkeley, MIT, the University of Washington, and the University of Waterloo have used it in their CS1 courses. Finally, Online Python Tutor visualizations have been embedded within three web-based digital Python textbook projects, which collectively attract around 16,000 viewers per month and are being used in at least 25 universities. Online Python Tutor is free and open source software, available at pythontutor.com.},
booktitle = {Proceeding of the 44th ACM Technical Symposium on Computer Science Education},
pages = {579–584},
numpages = {6},
keywords = {python, CS1, program visualization},
location = {Denver, Colorado, USA},
series = {SIGCSE '13}
}

@InProceedings{magpiebridge,
  author =	{Linghui Luo and Julian Dolby and Eric Bodden},
  title =	{{MagpieBridge: A General Approach to Integrating Static Analyses into IDEs and Editors (Tool Insights Paper)}},
  booktitle =	{33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
  pages =	{21:1--21:25},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-111-5},
  ISSN =	{1868-8969},
  year =	{2019},
  volume =	{134},
  editor =	{Alastair F. Donaldson},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10813},
  URN =		{urn:nbn:de:0030-drops-108139},
  doi =		{10.4230/LIPIcs.ECOOP.2019.21},
  annote =	{Keywords: IDE, Tool Support, Static Analysis, Language Server Protocol}
}

@inproceedings{alectryon,
author = {Pit-Claudel, Cl\'{e}ment},
title = {Untangling Mechanized Proofs},
year = {2020},
isbn = {9781450381765},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3426425.3426940},
doi = {10.1145/3426425.3426940},
abstract = {Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe the steps to take (induct on x, apply a theorem, …), not the states that these steps lead to; as a result, plain proof scripts are essentially incomprehensible without the assistance of an interactive user interface able to run the script and show the corresponding proof states. Until now, the standard process to communicate a proof without forcing readers to execute its script was to manually copy-paste intermediate proof states into the script, as source code comments — a tedious and error-prone exercise. Additional prose (such as for a book or tutorial) was likewise embedded in comments, preserving executability at the cost of a mediocre text-editing experience. This paper describes a new approach to the development and dissemination of literate proof scripts, with a focus on the Coq proof assistant. Specifically, we describe two contributions: a compiler that interleaves Coq’s output with the original proof script to produce interactive webpages that are complete, self-contained presentations of Coq proofs; and a new literate programming toolkit that allows authors to switch seamlessly between prose- and code-oriented views of the same sources, by translating back and forth between reStructuredText documents and literate Coq source files. In combination, these tools offer a new way to write, communicate, and preserve proofs, combining the flexibility of procedural proof scripts and the intelligibility of declarative proofs.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Software Language Engineering},
pages = {155–174},
numpages = {20},
keywords = {proof browsing, proof presentation, formal verification, literate programming},
location = {Virtual, USA},
series = {SLE 2020}
}

    @inproceedings{k-c,
    author = {Ellison, Chucky and Rosu, Grigore},
    title = {An Executable Formal Semantics of {C} with Applications},
    year = {2012},
    isbn = {9781450310833},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2103656.2103719},
    doi = {10.1145/2103656.2103719},
    abstract = {This paper describes an executable formal semantics of C. Being executable, the semantics has been thoroughly tested against the GCC torture test suite and successfully passes 99.2% of 776 test programs. It is the most complete and thoroughly tested formal definition of C to date. The semantics yields an interpreter, debugger, state space search tool, and model checker "for free". The semantics is shown capable of automatically finding program errors, both statically and at runtime. It is also used to enumerate nondeterministic behavior.},
    booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    pages = {533–544},
    numpages = {12},
    keywords = {k, semantics, C},
    location = {Philadelphia, PA, USA},
    series = {POPL '12}
    }

@article{cbench,
  author    = {Marko C. J. D. van Eekelen and
               Daniil Frumin and
               Herman Geuvers and
               L{\'{e}}on Gondelman and
               Robbert Krebbers and
               Marc Schoolderman and
               Sjaak Smetsers and
               Freek Verbeek and
               Beno{\^{\i}}t Viguier and
               Freek Wiedijk},
  title     = {A benchmark for {C} program verification},
  journal   = {CoRR},
  volume    = {abs/1904.01009},
  year      = {2019},
  url       = {http://arxiv.org/abs/1904.01009},
  eprinttype = {arXiv},
  eprint    = {1904.01009},
  timestamp = {Thu, 14 Oct 2021 09:15:19 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1904-01009.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{rustviz,
  author    = {Gongming Luo and
               Vishnu Reddy and
               Marcelo Almeida and
               Yingying Zhu and
               Ke Du and
               Cyrus Omar},
  title     = {RustViz: Interactively Visualizing Ownership and Borrowing},
  journal   = {CoRR},
  volume    = {abs/2011.09012},
  year      = {2020},
  url       = {https://arxiv.org/abs/2011.09012},
  eprinttype = {arXiv},
  eprint    = {2011.09012},
  timestamp = {Wed, 25 Nov 2020 16:34:14 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2011-09012.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{ribbon-proofs,
author="Wickerson, John
and Dodds, Mike
and Parkinson, Matthew",
editor="Felleisen, Matthias
and Gardner, Philippa",
title="Ribbon Proofs for Separation Logic",
booktitle="Programming Languages and Systems",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="189--208",
abstract="We present ribbon proofs, a diagrammatic system for proving program correctness based on separation logic. Ribbon proofs emphasise the structure of a proof, so are intelligible and pedagogical. Because they contain less redundancy than proof outlines, and allow each proof step to be checked locally, they may be more scalable. Where proof outlines are cumbersome to modify, ribbon proofs can be visually manoeuvred to yield proofs of variant programs. This paper introduces the ribbon proof system, proves its soundness and completeness, and outlines a prototype tool for validating the diagrams in Isabelle.",
isbn="978-3-642-37036-6"
}

@InProceedings{gradual-verification,
author="Bader, Johannes
and Aldrich, Jonathan
and Tanter, {\'E}ric",
editor="Dillig, Isil
and Palsberg, Jens",
title="Gradual Program Verification",
booktitle="Verification, Model Checking, and Abstract Interpretation",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="25--46",
abstract="Both static and dynamic program verification approaches have significant disadvantages when considered in isolation. Inspired by research on gradual typing, we propose gradual verification to seamlessly and flexibly combine static and dynamic verification. Drawing on general principles from abstract interpretation, and in particular on the recent Abstracting Gradual Typing methodology of Garcia et al., we systematically derive a gradual verification system from a static one. This approach yields, by construction, a gradual verification system that is compatible with the original static system, but overcomes its rigidity by resorting to dynamic verification when desired. As with gradual typing, the programmer can control the trade-off between static and dynamic checking by tuning the (im)precision of pre- and postconditions. The formal semantics of the gradual verification system and the proofs of its properties, including the gradual guarantees of Siek et al., have been fully mechanized in the Coq proof assistant.",
isbn="978-3-319-73721-8"
}

@inproceedings{icoq,
author = {Celik, Ahmet and Palmskog, Karl and Gligoric, Milos},
title = {A Regression Proof Selection Tool for Coq},
year = {2018},
isbn = {9781450356633},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3183440.3183493},
doi = {10.1145/3183440.3183493},
abstract = {Large-scale software verification projects increasingly rely on proof assistants, such as Coq, to construct formal proofs of program correctness. However, such proofs must be checked after every change to a project to ensure expected program behavior. This process of regression proving can require substantial machine time, which is detrimental to productivity and trust in evolving projects. We present iCoq, the first regression proof selection tool. iCoq tracks fine-grained dependencies between Coq definitions, propositions, and proofs, and only checks those proofs affected by changes between two revisions. iCoq is suitable for workflows involving version control and continuous integration services, e.g., Travis CI. We applied iCoq to track dependencies across many revisions in several large Coq projects and measured the time savings compared to proof checking from scratch and when using Coq's timestamp-based toolchain for incremental checking. Our results show that proof checking with iCoq is up to 10 times faster than the former and up to 3 times faster than the latter. The demo video for iCoq can be found at: https://www.youtube.com/watch?v=egFnHkH5pXI.},
booktitle = {Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings},
pages = {117–120},
numpages = {4},
keywords = {regression proof selection, proof engineering, coq, proof assistants},
location = {Gothenburg, Sweden},
series = {ICSE '18}
}

@article{vst-a,
author = {Zhou, Litao and Qin, Jianxing and Wang, Qinshi and Appel, Andrew W. and Cao, Qinxiang},
title = {VST-A: A Foundationally Sound Annotation Verifier},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632911},
doi = {10.1145/3632911},
abstract = {Program verifiers for imperative languages such as C may be annotation-based, in which assertions and invariants are put into source files and then checked, or tactic-based, where proof scripts separate from programs are interactively developed in a proof assistant such as Coq. Annotation verifiers have been more automated and convenient, but some interactive verifiers have richer assertion languages and formal proofs of soundness. We present VST-A, an annotation verifier that uses the rich assertion language of VST, leverages the formal soundness proof of VST, but allows users to describe functional correctness proofs intuitively by inserting assertions.VST-A analyzes control flow graphs, decomposes every C function into control flow paths between assertions, and reduces program verification problems into corresponding straightline Hoare triples. Compared to existing foundational program verification tools like VST and Iris, in VST-A such decompositions and reductions can nonstructural, which makes VST-A more flexible to use.VST-A’s decomposition and reduction is defined in Coq, proved sound in Coq, and computed call-by-value in Coq. The soundness proof for reduction is totally logical, independent of the complicated semantic model (and soundness proof) of VST’s Hoare triple. Because of the rich assertion language, not all reduced proof goals can be automatically checked, but the system allows users to prove residual proof goals using the full power of the Coq proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {69},
numpages = {30},
keywords = {Annotated Programs, Foundational Verification, Coq}
}

@InProceedings{infer,
author="Calcagno, Cristiano
and Distefano, Dino",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="Infer: An Automatic Program Verifier for Memory Safety of {C} Programs",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="459--465",
abstract="Infer is a new automatic program verification tool aimed at proving memory safety of C programs. It attempts to build a compositional proof of the program at hand by composing proofs of its constituent modules (functions/procedures). Bugs are extracted from failures of proof attempts. We describe the main features of Infer and some of the main ideas behind it.",
isbn="978-3-642-20398-5"
}

@inproceedings{viper,
  author      = {P. M{\"u}ller and M. Schwerhoff and A. J. Summers},
  title       = {Viper: A Verification Infrastructure for Permission-Based Reasoning},
  booktitle   = {Verification, Model Checking, and Abstract Interpretation (VMCAI)},
  editor      = {B. Jobstmann and K. R. M. Leino},
  year        = {2016},
  publisher   = {Springer-Verlag},
  series      = {LNCS},
  pages       = {41-62},
  volume      = {9583},
  url = {https://doi.org/10.1007/978-3-662-49122-5_2},
  urltext = {[Publisher]}
}

@InProceedings{verifast,
author="Jacobs, Bart
and Smans, Jan
and Philippaerts, Pieter
and Vogels, Fr{\'e}d{\'e}ric
and Penninckx, Willem
and Piessens, Frank",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="{VeriFast}: A Powerful, Sound, Predictable, Fast Verifier for {C} and {Java}",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--55",
abstract="VeriFast is a prototype verification tool for single-threaded and multithreaded C and Java programs. In this paper, we first describe the basic symbolic execution approach in some formal detail. Then we zoom in on two technical aspects: the approach to permission accounting, including fractional permissions, precise predicates, and counting permissions; and the approach to lemma function termination in the presence of dynamically-bound lemma function calls. Finally, we describe three ongoing efforts: application to JavaCard programs, integration of shape analysis, and application to Linux device drivers.",
isbn="978-3-642-20398-5"
}

@inproceedings{dafny,
author = {Leino, Rustan},
title = {Dafny: An Automatic Program Verifier for Functional Correctness},
booktitle = {16th International Conference, LPAR-16, Dakar, Senegal},
year = {2010},
month = {April},
abstract = {Traditionally, the full verification of a program’s functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.

This paper gives a tour of the language and verifier Dafny, which has been used to verify the functional correctness of a number of challenging pointer-based programs. The paper describes the features incorporated in Dafny, illustrating their use by small examples and giving a taste of how they are coded for an SMT solver. As a larger case study, the paper shows the full functional specification of the Schorr-Waite algorithm in Dafny.},
publisher = {Springer Berlin Heidelberg},
url = {https://www.microsoft.com/en-us/research/publication/dafny-automatic-program-verifier-functional-correctness-2/},
pages = {348-370},
edition = {16th International Conference, LPAR-16, Dakar, Senegal},
}

@inproceedings{armada,
author = {Lorch, Jacob R. and Chen, Yixuan and Kapritsos, Manos and Parno, Bryan and Qadeer, Shaz and Sharma, Upamanyu and Wilcox, James R. and Zhao, Xueyuan},
title = {Armada: Low-Effort Verification of High-Performance Concurrent Programs},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3385971},
doi = {10.1145/3385412.3385971},
abstract = {Safely writing high-performance concurrent programs is notoriously difficult. To aid developers, we introduce Armada, a language and tool designed to formally verify such programs with relatively little effort. Via a C-like language and a small-step, state-machine-based semantics, Armada gives developers the flexibility to choose arbitrary memory layout and synchronization primitives so they are never constrained in their pursuit of performance. To reduce developer effort, Armada leverages SMT-powered automation and a library of powerful reasoning techniques, including rely-guarantee, TSO elimination, reduction, and alias analysis. All these techniques are proven sound, and Armada can be soundly extended with additional strategies over time. Using Armada, we verify four concurrent case studies and show that we can achieve performance equivalent to that of unverified code.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {197–210},
numpages = {14},
keywords = {refinement, weak memory models, x86-TSO},
location = {London, UK},
series = {PLDI 2020}
}

@article{itrees,
author = {Xia, Li-yao and Zakowski, Yannick and He, Paul and Hur, Chung-Kil and Malecha, Gregory and Pierce, Benjamin C. and Zdancewic, Steve},
title = {Interaction Trees: Representing Recursive and Impure Programs in Coq},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371119},
doi = {10.1145/3371119},
abstract = {Interaction trees (ITrees) are a general-purpose data structure for representing the behaviors of recursive programs that interact with their environments. A coinductive variant of “free monads,” ITrees are built out of uninterpreted events and their continuations. They support compositional construction of interpreters from event handlers, which give meaning to events by defining their semantics as monadic actions. ITrees are expressive enough to represent impure and potentially nonterminating, mutually recursive computations, while admitting a rich equational theory of equivalence up to weak bisimulation. In contrast to other approaches such as relationally specified operational semantics, ITrees are executable via code extraction, making them suitable for debugging, testing, and implementing software artifacts that are amenable to formal verification. We have implemented ITrees and their associated theory as a Coq library, mechanizing classic domain- and category-theoretic results about program semantics, iteration, monadic structures, and equational reasoning. Although the internals of the library rely heavily on coinductive proofs, the interface hides these details so that clients can use and reason about ITrees without explicit use of Coq’s coinduction tactics. To showcase the utility of our theory, we prove the termination-sensitive correctness of a compiler from a simple imperative source language to an assembly-like target whose meanings are given in an ITree-based denotational semantics. Unlike previous results using operational techniques, our bisimulation proof follows straightforwardly by structural induction and elementary rewriting via an equational theory of combinators for control-flow graphs.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {51},
numpages = {32},
keywords = {monads, Coq, compiler correctness, coinduction}
}

@InProceedings{kvserver,
  author =	{Zhang, Hengchu and Honor\'{e}, Wolf and Koh, Nicolas and Li, Yao and Li, Yishuai and Xia, Li-Yao and Beringer, Lennart and Mansky, William and Pierce, Benjamin and Zdancewic, Steve},
  title =	{{Verifying an HTTP Key-Value Server with Interaction Trees and VST}},
  booktitle =	{12th International Conference on Interactive Theorem Proving (ITP 2021)},
  pages =	{32:1--32:19},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-188-7},
  ISSN =	{1868-8969},
  year =	{2021},
  volume =	{193},
  editor =	{Cohen, Liron and Kaliszyk, Cezary},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/opus/volltexte/2021/13927},
  URN =		{urn:nbn:de:0030-drops-139273},
  doi =		{10.4230/LIPIcs.ITP.2021.32},
  annote =	{Keywords: formal verification, Coq, HTTP, deep specification}
}

@inproceedings{compass,
author = {Dang, Hoang-Hai and Jung, Jaehwang and Choi, Jaemin and Nguyen, Duc-Than and Mansky, William and Kang, Jeehoon and Dreyer, Derek},
title = {Compass: Strong and Compositional Library Specifications in Relaxed Memory Separation Logic},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523451},
doi = {10.1145/3519939.3523451},
abstract = {Several functional correctness criteria have been proposed for relaxed-memory consistency libraries, but most lack support for modular client reasoning. M\'{e}vel and Jourdan recently showed that logical atomicity can be used to give strong modular Hoare-style specifications for relaxed libraries, but only for a limited instance in the Multicore OCaml memory model. It has remained unclear if their approach scales to weaker implementations in weaker memory models. In this work, we combine logical atomicity together with richer partial orders (inspired by prior relaxed-memory correctness criteria) to develop stronger specifications in the weaker memory model of Repaired C11 (RC11). We show their applicability by proving them for multiple implementations of stacks, queues, and exchangers, and we demonstrate their strength by performing multiple client verifications on top of them. Our proofs are mechanized in Compass, a new framework extending the iRC11 separation logic, built atop Iris, in Coq. We report the first mechanized verifications of relaxed-memory implementations for the exchanger, the elimination stack, and the Herlihy-Wing queue.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {792–808},
numpages = {17},
keywords = {linearizability, separation logics, logical atomicity, relaxed memory models, C11, Iris},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@InProceedings{SVCOMP12,
author="Beyer, Dirk",
editor="Flanagan, Cormac
and K{\"o}nig, Barbara",
title="Competition on Software Verification",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="504--524",
abstract="This report describes the definitions, rules, setup, procedure, and results of the 1st International Competition on Software Verification. The verification community has performed competitions in various areas in the past, and SV-COMP'12 is the first competition of verification tools that take software programs as input and run a fully automatic verification of a given safety property. This year's competition is organized as a satellite event of the International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS).",
isbn="978-3-642-28756-5"
}


        
@misc{clightgen-normalize,
  author = {Leroy, Xavier},
  title = {{CompCert}},
  year = {2017},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/AbsInt/CompCert/commit/446cff1087ffe40d9b19b616162212ca83677515}},
  commit = {446cff1087ffe40d9b19b616162212ca83677515}
}

@misc{vscoq, author={Maxime Dénès}, title={{VsCoq}}, url={https://github.com/coq-community/vscoq}, howpublished = "\url{https://github.com/coq-community/vscoq}",publisher={GitHub}, journal={GitHub repository}, year={2022}}

@misc{coq-platform, author={Michael Soegtrop}, title={{The Coq Platform}}, url={https://github.com/coq/platform}, howpublished = "\url{https://github.com/coq/platform}", publisher={GitHub}, journal={GitHub repository}, year={2023}}

@InProceedings{lav-smt,
author="Vujo{\v{s}}evi{\'{c}}-Jani{\v{c}}i{\'{c}}, Milena
and Kuncak, Viktor",
editor="Joshi, Rajeev
and M{\"u}ller, Peter
and Podelski, Andreas",
title="Development and Evaluation of {LAV}: An {SMT}-Based Error Finding Platform",
booktitle="Verified Software: Theories, Tools, Experiments",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="98--113",
abstract="We present design and evaluation of LAV, a new open-source tool for statically checking program assertions and errors. LAV integrates into the popular LLVM infrastructure for compilation and analysis. LAV uses symbolic execution to construct a first-order logic formula that models the behavior of each basic blocks. It models the relationships between basic blocks using propositional formulas. By combining these two kinds of formulas LAV generates polynomial-sized verification conditions for loop-free code. It uses underapproximating or overapproximating unrolling to handle loops. LAV can pass generated verification conditions to one of the several SMT solvers: Boolector, MathSAT, Yices, and Z3. Our experiments with small 200 benchmarks suggest that LAV is competitive with related tools, so it can be used as an effective alternative for certain verification tasks. The experience also shows that LAV provides significant help in analyzing student programs and providing feedback to students in everyday university practice.",
isbn="978-3-642-27705-4"
}

@article{hazel-holes,
author = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A.},
title = {Live Functional Programming with Typed Holes},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290327},
doi = {10.1145/3290327},
abstract = {Live programming environments aim to provide programmers (and sometimes audiences) with continuous feedback about a program's dynamic behavior as it is being edited. The problem is that programming languages typically assign dynamic meaning only to programs that are complete, i.e. syntactically well-formed and free of type errors. Consequently, live feedback presented to the programmer exhibits temporal or perceptive gaps. This paper confronts this "gap problem" from type-theoretic first principles by developing a dynamic semantics for incomplete functional programs, starting from the static semantics for incomplete functional programs developed in recent work on Hazelnut. We model incomplete functional programs as expressions with holes, with empty holes standing for missing expressions or types, and non-empty holes operating as membranes around static and dynamic type inconsistencies. Rather than aborting when evaluation encounters any of these holes as in some existing systems, evaluation proceeds around holes, tracking the closure around each hole instance as it flows through the remainder of the program. Editor services can use the information in these hole closures to help the programmer develop and confirm their mental model of the behavior of the complete portions of the program as they decide how to fill the remaining holes. Hole closures also enable a fill-and-resume operation that avoids the need to restart evaluation after edits that amount to hole filling. Formally, the semantics borrows machinery from both gradual type theory (which supplies the basis for handling unfilled type holes) and contextual modal type theory (which supplies a logical basis for hole closures), combining these and developing additional machinery necessary to continue evaluation past holes while maintaining type safety. We have mechanized the metatheory of the core calculus, called Hazelnut Live, using the Agda proof assistant. We have also implemented these ideas into the Hazel programming environment. The implementation inserts holes automatically, following the Hazelnut edit action calculus, to guarantee that every editor state has some (possibly incomplete) type. Taken together with this paper's type safety property, the result is a proof-of-concept live programming environment where rich dynamic feedback is truly available without gaps, i.e. for every reachable editor state.},
journal = {Proc. ACM Program. Lang.},
month = {Jan},
articleno = {14},
numpages = {32},
keywords = {typed holes, gradual typing, structured editing, contextual modal type theory, live programming}
}

@article{incomplete-c,
author = {Melo, Leandro T. C. and Ribeiro, Rodrigo G. and de Ara\'{u}jo, Marcus R. and Pereira, Fernando Magno Quint\~{a}o},
title = {Inference of Static Semantics for Incomplete {C} Programs},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158117},
doi = {10.1145/3158117},
abstract = {Incomplete source code naturally emerges in software development: during the design phase, while evolving, testing and analyzing programs. Therefore, the ability to understand partial programs is a valuable asset. However, this problem is still unsolved in the C programming language. Difficulties stem from the fact that parsing C requires, not only syntax, but also semantic information. Furthermore, inferring types so that they respect C's type system is a challenging task. In this paper we present a technique that lets us solve these problems. We provide a unification-based type inference capable of dealing with C intricacies. The ideas we present let us reconstruct partial C programs into complete well-typed ones. Such program reconstruction has several applications: enabling static analysis tools in scenarios where software components may be absent; improving static analysis tools that do not rely on build-specifications; allowing stub-generation and testing tools to work on snippets; and assisting programmers on the extraction of reusable data-structures out of the program parts that use them. Our evaluation is performed on source code from a variety of C libraries such as GNU's Coreutils, GNULib, GNOME's GLib, and GDSL; on implementations from Sedgewick's books; and on snippets from popular open-source projects like CPython, FreeBSD, and Git.},
journal = {Proc. ACM Program. Lang.},
month = {Dec},
articleno = {29},
numpages = {28},
keywords = {Partial Programs, C Language, Parsing, Type Inference}
}

@article{fuzzy-parsing,
author = {Koppler, Rainer},
title = {A Systematic Approach to Fuzzy Parsing},
year = {1997},
issue_date = {June 1997},
publisher = {John Wiley & Sons, Inc.},
address = {USA},
volume = {27},
number = {6},
issn = {0038-0644},
url = {https://doi.org/10.1002/(SICI)1097-024X(199706)27:6%3C637::AID-SPE99%3E3.0.CO;2-3},
doi = {10.1002/(SICI)1097-024X(199706)27:6%3C637::AID-SPE99%3E3.0.CO;2-3},
journal = {Softw. Pract. Exper.},
month = {Jun},
pages = {637–649},
numpages = {13},
keywords = {C++, syntax analysis, software tools, object-oriented design, frameworks}
}

@misc{reST,
  title = {{reStructuredText} Markup Specification},
  author = {David Goodger},
  note= {\url{https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html}},
  url = {https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html},
  year = {2020},
  month = {Jul}
}

@misc{lsp,
  title = {{Language Server Protocol}},
  note = {\url{https://microsoft.github.io/language-server-protocol/}},
  author = {Microsoft},
  url = {https://microsoft.github.io/language-server-protocol/},
  year = {2021}
}

  @inproceedings{graphical-lsp,
author = {Rodriguez-Echeverria, Roberto and Izquierdo, Javier Luis C\'{a}novas and Wimmer, Manuel and Cabot, Jordi},
title = {Towards a Language Server Protocol Infrastructure for Graphical Modeling},
year = {2018},
isbn = {9781450349499},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3239372.3239383},
doi = {10.1145/3239372.3239383},
abstract = {The development of modern IDEs is still a challenging and time-consuming task, which requires implementing the support for language-specific features such as syntax highlighting or validation. When the IDE targets a graphical language, its development becomes even more complex due to the rendering and manipulation of the graphical notation symbols. To simplify the development of IDEs, the Language Server Protocol (LSP) proposes a decoupled approach based on language-agnostic clients and language-specific servers. LSP clients communicate changes to LSP servers, which validate and store language instances. However, LSP only addresses textual languages (i.e., character as atomic unit) and neglects the support for graphical ones (i.e., nodes/edges as atomic units). In this paper, we present our vision to decouple graphical language IDEs discussing the alternatives for integrating LSP's ideas in their development. Moreover, we propose a novel LSP infrastructure to simplify the development of new graphical modeling tools, in which Web technologies may be used for editor front-ends while leveraging existing modeling frameworks to build language servers.},
booktitle = {Proceedings of the 21th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems},
pages = {370–380},
numpages = {11},
keywords = {Domain Specific Languages, Language Server Protocol, Modeling Editors},
location = {Copenhagen, Denmark},
series = {MODELS '18}
}

@article{suslik,
author = {Polikarpova, Nadia and Sergey, Ilya},
title = {Structuring the Synthesis of Heap-Manipulating Programs},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290385},
doi = {10.1145/3290385},
abstract = {This paper describes a deductive approach to synthesizing imperative programs with pointers from declarative specifications expressed in Separation Logic. Our synthesis algorithm takes as input a pair of assertions—a pre- and a postcondition—which describe two states of the symbolic heap, and derives a program that transforms one state into the other, guided by the shape of the heap. Our approach to program synthesis is grounded in proof theory: we introduce the novel framework of Synthetic Separation Logic (SSL), which generalises the classical notion of heap entailment P ⊢ Q to incorporate a possibility of transforming a heap satisfying an assertion P into a heap satisfying an assertion Q. A synthesized program represents a proof term for a transforming entailment statement P ↝ Q, and the synthesis procedure corresponds to a proof search. The derived programs are, thus, correct by construction, in the sense that they satisfy the ascribed pre/postconditions, and are accompanied by complete proof derivations, which can be checked independently. We have implemented a proof search engine for SSL in a form of the program synthesizer called SuSLik. For efficiency, the engine exploits properties of SSL rules, such as invertibility and commutativity of rule applications on separate heaps, to prune the space of derivations it has to consider. We explain and showcase the use of SSL on characteristic examples, describe the design of SuSLik, and report on our experience of using it to synthesize a series of benchmark programs manipulating heap-based linked data structures.},
journal = {Proc. ACM Program. Lang.},
month = {Jan},
articleno = {72},
numpages = {30},
keywords = {Separation Logic, Proof Systems, Program Synthesis, Type Theory}
}

@INPROCEEDINGS{eiffel,

  author={Meyer, B.},

  booktitle={Proceedings. Technology of Object-Oriented Languages. TOOLS 26 (Cat. No.98EX176)}, 

  title={Design By Contract. The Eiffel Method}, 

  year={1998},

  volume={},

  number={},

  pages={446-446},

  doi={10.1109/TOOLS.1998.711043}}

@inproceedings{proof-repair,
author = {Ringer, Talia and Porter, RanDair and Yazdani, Nathaniel and Leo, John and Grossman, Dan},
title = {Proof Repair across Type Equivalences},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454033},
doi = {10.1145/3453483.3454033},
abstract = {We describe a new approach to automatically repairing broken proofs in the Coq proof assistant in response to changes in types. Our approach combines a configurable proof term transformation with a decompiler from proof terms to suggested tactic scripts. The proof term transformation implements transport across equivalences in a way that removes references to the old version of the changed type and does not rely on axioms beyond those Coq assumes. We have implemented this approach in Pumpkin Pi, an extension to the Pumpkin Patch Coq plugin suite for proof repair. We demonstrate Pumpkin Pi’s flexibility on eight case studies, including supporting a benchmark from a user study,easing development with dependent types, porting functions and proofs between unary and binary numbers, and supporting an industrial proof engineer to interoperate between Coq and other verification tools more easily.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {112–127},
numpages = {16},
keywords = {proof repair, proof engineering, proof reuse},
location = {Virtual, Canada},
series = {PLDI 2021}
}

  @inproceedings{DBLP:conf/pldi/Sanchez-SternAS20,
  author    = {Alex Sanchez{-}Stern and
               Yousef Alhessi and
               Lawrence K. Saul and
               Sorin Lerner},
  editor    = {Koushik Sen and
               Mayur Naik},
  title     = {Generating correctness proofs with neural networks},
  booktitle = {Proceedings of the 4th {ACM} {SIGPLAN} International Workshop on Machine
               Learning and Programming Languages, MAPL@PLDI 2020, London, UK, June
               15, 2020},
  pages     = {1--10},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3394450.3397466},
  doi       = {10.1145/3394450.3397466},
  timestamp = {Mon, 15 Jun 2020 11:17:59 +0200},
  biburl    = {https://dblp.org/rec/conf/pldi/Sanchez-SternAS20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{yang2019coqgym,
  title={Learning to Prove Theorems via Interacting with Proof Assistants},
  author={Yang, Kaiyu and Deng, Jia},
  booktitle={International Conference on Machine Learning (ICML)},
  year={2019}
}

@book{isabelle,
author = {Nipkow, Tobias and Wenzel, Markus and Paulson, Lawrence C.},
title = {Isabelle/HOL: A Proof Assistant for Higher-Order Logic},
year = {2002},
isbn = {3540433767},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
} 

@inproceedings{pointer-casts,
author = {Kang, Jeehoon and Hur, Chung-Kil and Mansky, William and Garbuzov, Dmitri and Zdancewic, Steve and Vafeiadis, Viktor},
title = {A Formal {C} Memory Model Supporting Integer-Pointer Casts},
year = {2015},
isbn = {9781450334686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2737924.2738005},
doi = {10.1145/2737924.2738005},
abstract = {The ISO C standard does not specify the semantics of many valid programs that use non-portable idioms such as integer-pointer casts. Recent efforts at formal definitions and verified implementation of the C language inherit this feature. By adopting high-level abstract memory models, they validate common optimizations. On the other hand, this prevents reasoning about much low-level code relying on the behavior of common implementations, where formal verification has many applications. We present the first formal memory model that allows many common optimizations and fully supports operations on the representation of pointers. All arithmetic operations are well-defined for pointers that have been cast to integers. Crucially, our model is also simple to understand and program with. All our results are fully formalized in Coq.},
booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {326–335},
numpages = {10},
keywords = {Compiler, Optimization, C Memory Model, Verification, Integer-Pointer Cast},
location = {Portland, OR, USA},
series = {PLDI '15}
}

@inproceedings{demanded-abstract-interpretation,
author = {Stein, Benno and Chang, Bor-Yuh Evan and Sridharan, Manu},
title = {Demanded Abstract Interpretation},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454044},
doi = {10.1145/3453483.3454044},
abstract = {We consider the problem of making expressive static analyzers interactive. Formal static analysis is seeing increasingly widespread adoption as a tool for verification and bug-finding, but even with powerful cloud infrastructure it can take minutes or hours to get batch analysis results after a code change. While existing techniques offer some demand-driven or incremental aspects for certain classes of analysis, the fundamental challenge we tackle is doing both for arbitrary abstract interpreters. Our technique, demanded abstract interpretation, lifts program syntax and analysis state to a dynamically evolving graph structure, in which program edits, client-issued queries, and evaluation of abstract semantics are all treated uniformly. The key difficulty addressed by our approach is the application of general incremental computation techniques to the complex, cyclic dependency structure induced by abstract interpretation of loops with widening operators. We prove that desirable abstract interpretation meta-properties, including soundness and termination, are preserved in our approach, and that demanded analysis results are equal to those computed by a batch abstract interpretation. Experimental results suggest promise for a prototype demanded abstract interpretation framework: by combining incremental and demand-driven techniques, our framework consistently delivers analysis results at interactive speeds, answering 95% of queries within 1.2 seconds.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {282–295},
numpages = {14},
keywords = {Incremental computation, Abstract interpretation, Demanded fixed points, Demand-driven query evaluation},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@inproceedings{swap-server,
author = {Koh, Nicolas and Li, Yao and Li, Yishuai and Xia, Li-yao and Beringer, Lennart and Honor\'{e}, Wolf and Mansky, William and Pierce, Benjamin C. and Zdancewic, Steve},
title = {From {C} to Interaction Trees: Specifying, Verifying, and Testing a Networked Server},
year = {2019},
isbn = {9781450362221},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3293880.3294106},
doi = {10.1145/3293880.3294106},
abstract = {We present the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward “one client at a time” style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.},
booktitle = {Proceedings of the 8th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {234–248},
numpages = {15},
keywords = {QuickChick, testing, network refinement, interaction trees, formal verification, VST, TCP},
location = {Cascais, Portugal},
series = {CPP 2019}
}

@inproceedings{dezyne,
  author    = {Rutger van Beusekom and
               Bert de Jonge and
               Paul F. Hoogendijk and
               Jan Nieuwenhuizen},
  editor    = {Jos{\'{e}} Proen{\c{c}}a and
               Andrei Paskevich},
  title     = {Dezyne: Paving the Way to Practical Formal Software Engineering},
  booktitle = {Proceedings of the 6th Workshop on Formal Integrated Development Environment,
               F-IDE@NFM 2021, Held online, 24-25th May 2021},
  series    = {{EPTCS}},
  volume    = {338},
  pages     = {19--30},
  year      = {2021},
  url       = {https://doi.org/10.4204/EPTCS.338.4},
  doi       = {10.4204/EPTCS.338.4},
  timestamp = {Mon, 29 Nov 2021 16:32:05 +0100},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2108-02962.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@ARTICLE{findbugs,

  author={Ayewah, Nathaniel and Pugh, William and Hovemeyer, David and Morgenthaler, J. David and Penix, John},

  journal={IEEE Software}, 

  title={Using Static Analysis to Find Bugs}, 

  year={2008},

  volume={25},

  number={5},

  pages={22-29},

  doi={10.1109/MS.2008.130}}

@article{iris-vst-arxiv,
  doi = {10.48550/ARXIV.2207.06574},
  
  journal   = {CoRR},
  volume    = {abs/2207.06574},

  url = {https://arxiv.org/abs/2207.06574},
  
  author = {Mansky, William},
  
  keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences, F.3.1},
  
  title = {Bringing {Iris} into the {Verified Software Toolchain}},
  
  publisher = {arXiv},
  
  year = {2022},
  
  copyright = {Creative Commons Attribution Non Commercial Share Alike 4.0 International}
}

@article{javert,
author = {Fragoso Santos, Jos\'{e} and Maksimovi\'{c}, Petar and Naud\v{z}i\={u}niene, Daiva and Wood, Thomas and Gardner, Philippa},
title = {{JaVerT}: {JavaScript} Verification Toolchain},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158138},
doi = {10.1145/3158138},
abstract = {The dynamic nature of JavaScript and its complex semantics make it a difficult target for logic-based verification. We introduce JaVerT, a semi-automatic JavaScript Verification Toolchain, based on separation logic and aimed at the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code. To specify JavaScript programs, we design abstractions that capture its key heap structures (for example, prototype chains and function closures), allowing the developer to write clear and succinct specifications with minimal knowledge of the JavaScript internals. To verify JavaScript programs, we develop JaVerT, a verification pipeline consisting of: JS-2-JSIL, a well-tested compiler from JavaScript to JSIL, an intermediate goto language capturing the fundamental dynamic features of JavaScript; JSIL Verify, a semi-automatic verification tool based on a sound JSIL separation logic; and verified axiomatic specifications of the JavaScript internal functions. Using JaVerT, we verify functional correctness properties of: data-structure libraries (key-value map, priority queue) written in an object-oriented style; operations on data structures such as binary search trees (BSTs) and lists; examples illustrating function closures; and test cases from the official ECMAScript test suite. The verification times suggest that reasoning about larger, more complex code using JaVerT is feasible.},
journal = {Proc. ACM Program. Lang.},
month = {Dec},
articleno = {50},
numpages = {33},
keywords = {JavaScript verification, Frame inference, Dynamic language verification, Intermediate representations, Programming language design and implementation}
}

@article{pvsio-web,
  author    = {Patrick Oladimeji and
               Paolo Masci and
               Paul Curzon and
               Harold W. Thimbleby},
  title     = {PVSio-web: a tool for rapid prototyping device user interfaces in
               {PVS}},
  journal   = {Electron. Commun. Eur. Assoc. Softw. Sci. Technol.},
  volume    = {69},
  year      = {2013},
  url       = {https://doi.org/10.14279/tuj.eceasst.69.963},
  doi       = {10.14279/tuj.eceasst.69.963},
  timestamp = {Tue, 01 Jun 2021 08:33:35 +0200},
  biburl    = {https://dblp.org/rec/journals/eceasst/OladimejiMCT13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@techreport{GallegoArias2016SerAPI,
  title = {{SerAPI: Machine-Friendly, Data-Centric Serialization for Coq}},
  author = {Gallego Arias, Emilio Jes{\'u}s},
  url = {https://hal-mines-paristech.archives-ouvertes.fr/hal-01384408},
  institution = {MINES ParisTech},
  year = {2016},
  month = Oct,
}

@article{iris-vst2,
  author = {Mansky, William},
  
  keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences, F.3.1},
  
  title = {Updating a Verifier with {Iris}'s Concurrency Logic},
  
  year = {2023},
  
  note = {In submission to PLDI 2023.}
}

@unpublished{bst-conc,
author = {Sharma, Roshan and Wang, Shengyi and Oey, Alexander and Evdokimova, Anastasiia and Beringer, Lennart and Mansky, William},
title = {Proving Logical Atomicity using Lock Invariants},
year = {2022},
note = {Presented at Advances in Separation Logic (ASL 2022)}
}

@inproceedings{cfrontend,
  author = {Sandrine Blazy and Zaynah Dargaye and Xavier Leroy},
  title = {Formal Verification of a {C} Compiler Front-End},
  booktitle = {FM 2006: Int. Symp. on Formal Methods},
  series = {Lecture Notes in Computer Science},
  publisher = {Springer},
  volume = 4085,
  year = 2006,
  pages = {460--475},
  url = {http://xavierleroy.org/publi/cfront.pdf},
  urlpublisher = {http://dx.doi.org/10.1007/11813040_31},
  hal = {http://hal.inria.fr/inria-00106401/},
  abstract = {This paper presents the formal verification of a compiler front-end
that translates a subset of the C language into the Cminor
intermediate language.  The semantics of the source and target
languages as well as the translation between them have been written in
the specification language of the Coq proof assistant. The proof of
observational semantic equivalence between the source and generated
code has been machine-checked using Coq.  An executable compiler was
obtained by automatic extraction of executable Caml code from the Coq
specification of the translator, combined with a certified compiler
back-end generating PowerPC assembly code from Cminor, described in
previous work.},
  pubkind = {conf-int-multi}
}

@inproceedings{genmc,
author = {Kokologiannakis, Michalis and Raad, Azalea and Vafeiadis, Viktor},
title = {Model Checking for Weakly Consistent Libraries},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314609},
doi = {10.1145/3314221.3314609},
abstract = {We present GenMC, a model checking algorithm for concurrent programs that is parametric in the choice of memory model and can be used for verifying clients of concurrent libraries. Subject to a few basic conditions about the memory model, our algorithm is sound, complete and optimal, in that it explores each consistent execution of the program according to the model exactly once, and does not explore inconsistent executions or embark on futile exploration paths. We implement GenMC as a tool for verifying C programs. Despite the generality of the algorithm, its performance is comparable to the state-of-art specialized model checkers for specific memory models, and in certain cases exponentially faster thanks to its coarse partitioning of executions.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {96–110},
numpages = {15},
keywords = {Model checking, weak memory models},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@InProceedings{viper-weak,
author="Summers, Alexander J.
and M{\"u}ller, Peter",
editor="Beyer, Dirk
and Huisman, Marieke",
title="Automating Deductive Verification for Weak-Memory Programs",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="190--209",
abstract="Writing correct programs for weak memory models such as the C11 memory model is challenging because of the weak consistency guarantees these models provide. The first program logics for the verification of such programs have recently been proposed, but their usage has been limited thus far to manual proofs. Automating proofs in these logics via first-order solvers is non-trivial, due to features such as higher-order assertions, modalities and rich permission resources.",
isbn="978-3-319-89960-2"
}

@inproceedings{overhauling-c11,
author = {Batty, Mark and Donaldson, Alastair F. and Wickerson, John},
title = {Overhauling {SC} Atomics in {C11} and {OpenCL}},
year = {2016},
isbn = {9781450335492},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2837614.2837637},
doi = {10.1145/2837614.2837637},
abstract = {Despite the conceptual simplicity of sequential consistency (SC), the semantics of SC atomic operations and fences in the C11 and OpenCL memory models is subtle, leading to convoluted prose descriptions that translate to complex axiomatic formalisations. We conduct an overhaul of SC atomics in C11, reducing the associated axioms in both number and complexity. A consequence of our simplification is that the SC operations in an execution no longer need to be totally ordered. This relaxation enables, for the first time, efficient and exhaustive simulation of litmus tests that use SC atomics. We extend our improved C11 model to obtain the first rigorous memory model formalisation for OpenCL (which extends C11 with support for heterogeneous many-core programming). In the OpenCL setting, we refine the SC axioms still further to give a sensible semantics to SC operations that employ a ‘memory scope’ to restrict their visibility to specific threads. Our overhaul requires slight strengthenings of both the C11 and the OpenCL memory models, causing some behaviours to become disallowed. We argue that these strengthenings are natural, and that all of the formalised C11 and OpenCL compilation schemes of which we are aware (Power and x86 CPUs for C11, AMD GPUs for OpenCL) remain valid in our revised models. Using the HERD memory model simulator, we show that our overhaul leads to an exponential improvement in simulation time for C11 litmus tests compared with the original model, making *exhaustive* simulation competitive, time-wise, with the *non-exhaustive* CDSChecker tool.},
booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {634–648},
numpages = {15},
keywords = {program simulation, heterogeneous programming, graphics processing unit (GPU), language design, weak memory models, HOL theorem prover, Formal methods},
location = {St. Petersburg, FL, USA},
series = {POPL '16}
}

@article{herd-cats,
author = {Alglave, Jade and Maranget, Luc and Tautschnig, Michael},
title = {Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak Memory},
year = {2014},
issue_date = {July 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {36},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/2627752},
doi = {10.1145/2627752},
abstract = {We propose an axiomatic generic framework for modelling weak memory. We show how to instantiate this framework for Sequential Consistency (SC), Total Store Order (TSO), C++ restricted to release-acquire atomics, and Power. For Power, we compare our model to a preceding operational model in which we found a flaw. To do so, we define an operational model that we show equivalent to our axiomatic model.We also propose a model for ARM. Our testing on this architecture revealed a behaviour later acknowledged as a bug by ARM, and more recently, 31 additional anomalies.We offer a new simulation tool, called herd, which allows the user to specify the model of his choice in a concise way. Given a specification of a model, the tool becomes a simulator for that model. The tool relies on an axiomatic description; this choice allows us to outperform all previous simulation tools. Additionally, we confirm that verification time is vastly improved, in the case of bounded model checking.Finally, we put our models in perspective, in the light of empirical data obtained by analysing the C and C++ code of a Debian Linux distribution. We present our new analysis tool, called mole, which explores a piece of code to find the weak memory idioms that it uses.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {Jul},
articleno = {7},
numpages = {74},
keywords = {Concurrency, software verification, weak memory models}
}

@inproceedings{10.1145/3519939.3523718,
author = {Cho, Minki and Lee, Sung-Hwan and Lee, Dongjae and Hur, Chung-Kil and Lahav, Ori},
title = {Sequential Reasoning for Optimizing Compilers under Weak Memory Concurrency},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523718},
doi = {10.1145/3519939.3523718},
abstract = {We formally show that sequential reasoning is adequate and sufficient for establishing soundness of various compiler optimizations under weakly consistent shared-memory concurrency. Concretely, we introduce a sequential model and show that behavioral refinement in that model entails contextual refinement in the Promising Semantics model, extended with non-atomic accesses for non-racy code. This is the first work to achieve such result for a full-fledged model with a variety of C11-style concurrency features. Central to our model is the lifting of the common data-race-freedom assumption, which allows us to validate irrelevant load introduction, a transformation that is commonly performed by compilers. As a proof of concept, we develop an optimizer for a toy concurrent language, and certify it (in Coq) while relying solely on the sequential model. We believe that the proposed approach provides useful means for compiler developers and validators, as well as a solid foundation for the development of certified optimizing compilers for weakly consistent shared-memory concurrency.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {213–228},
numpages = {16},
keywords = {Compiler Optimizations, Relaxed Memory Concurrency, Operational Semantics},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

    @article{templates-multi,
    author = {Patel, Nisarg and Krishna, Siddharth and Shasha, Dennis and Wies, Thomas},
    title = {Verifying Concurrent Multicopy Search Structures},
    year = {2021},
    issue_date = {October 2021},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {5},
    number = {OOPSLA},
    url = {https://doi.org/10.1145/3485490},
    doi = {10.1145/3485490},
    abstract = {Multicopy search structures such as log-structured merge (LSM) trees are optimized for high insert/update/delete (collectively known as upsert) performance. In such data structures, an upsert on key k, which adds (k,v) where v can be a value or a tombstone, is added to the root node even if k is already present in other nodes. Thus there may be multiple copies of k in the search structure. A search on k aims to return the value associated with the most recent upsert. We present a general framework for verifying linearizability of concurrent multicopy search structures that abstracts from the underlying representation of the data structure in memory, enabling proof-reuse across diverse implementations. Based on our framework, we propose template algorithms for (a) LSM structures forming arbitrary directed acyclic graphs and (b) differential file structures, and formally verify these templates in the concurrent separation logic Iris. We also instantiate the LSM template to obtain the first verified concurrent in-memory LSM tree implementation.},
    journal = {Proc. ACM Program. Lang.},
    month = {Oct},
    articleno = {113},
    numpages = {32},
    keywords = {template-based verification, concurrent data structures, flow framework, log-structured merge trees, separation logic}
    }
    
@InProceedings{civl,
author="Hawblitzel, Chris
and Petrank, Erez
and Qadeer, Shaz
and Tasiran, Serdar",
editor="Kroening, Daniel
and P{\u{a}}s{\u{a}}reanu, Corina S.",
title="Automated and Modular Refinement Reasoning for Concurrent Programs",
booktitle="Computer Aided Verification",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="449--465",
abstract="We present civl, a language and verifier for concurrent programs based on automated and modular refinement reasoning. civl supports reasoning about a concurrent program at many levels of abstraction. Atomic actions in a high-level description are refined to fine-grain and optimized lower-level implementations. A novel combination of automata theoretic and logic-based checks is used to verify refinement. Modular specifications and proof annotations, such as location invariants and procedure pre- and post-conditions, are specified separately, independently at each level in terms of the variables visible at that level. We have implemented civl as an extension to the boogie language and verifier. We have used civl to refine a realistic concurrent garbage collection algorithm from a simple high-level specification down to a highly-concurrent implementation described in terms of individual memory accesses.",
isbn="978-3-319-21668-3"
}

@article{anchor,
author = {Flanagan, Cormac and Freund, Stephen N.},
title = {The {Anchor} Verifier for Blocking and Non-Blocking Concurrent Software},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428224},
doi = {10.1145/3428224},
abstract = {Verifying the correctness of concurrent software with subtle synchronization is notoriously challenging. We present the Anchor verifier, which is based on a new formalism for specifying synchronization disciplines that describes both (1) what memory accesses are permitted, and (2) how each permitted access commutes with concurrent operations of other threads (to facilitate reduction proofs). Anchor supports the verification of both lock-based blocking and cas-based non-blocking algorithms. Experiments on a variety concurrent data structures and algorithms show that Anchor significantly reduces the burden of concurrent verification.},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {156},
numpages = {29},
keywords = {reduction, synchronization, concurrent program verification}
}

@inproceedings{x86-tso,
author = {Owens, Scott and Sarkar, Susmit and Sewell, Peter},
title = {A Better X86 Memory Model: {x86-TSO}},
year = {2009},
isbn = {9783642033582},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-03359-9_27},
doi = {10.1007/978-3-642-03359-9_27},
abstract = {Real multiprocessors do not provide the sequentially consistent memory that is assumed by most work on semantics and verification. Instead, they have relaxed memory models, typically described in ambiguous prose, which lead to widespread confusion. These are prime targets for mechanized formalization. In previous work we produced a rigorous x86-CC model, formalizing the Intel and AMD architecture specifications of the time, but those turned out to be unsound with respect to actual hardware, as well as arguably too weak to program above. We discuss these issues and present a new x86-TSO model that suffers from neither problem, formalized in HOL4. We believe it is sound with respect to real processors, reflects better the vendor's intentions, and is also better suited for programming. We give two equivalent definitions of x86-TSO: an intuitive operational model based on local write buffers, and an axiomatic total store ordering model, similar to that of the SPARCv8. Both are adapted to handle x86-specific features. We have implemented the axiomatic model in our memevents tool, which calculates the set of all valid executions of test programs, and, for greater confidence, verify the witnesses of such executions directly, with code extracted from a third, more algorithmic, equivalent version of the definition.},
booktitle = {Proceedings of the 22nd International Conference on Theorem Proving in Higher Order Logics},
pages = {391–407},
numpages = {17},
location = {Munich, Germany},
series = {TPHOLs '09}
}

@article{reloc-reloaded,
author       = {Dan Frumin and
                  Robbert Krebbers and
                  Lars Birkedal},
  title        = {{ReLoC} Reloaded: {A} Mechanized Relational Logic for Fine-Grained Concurrency
                  and Logical Atomicity},
  journal      = {Log. Methods Comput. Sci.},
  volume       = {17},
  number       = {3},
  year         = {2021},
  url          = {https://doi.org/10.46298/lmcs-17(3:9)2021},
  doi          = {10.46298/lmcs-17(3:9)2021},
  timestamp    = {Tue, 24 Jan 2023 10:48:24 +0100},
  biburl       = {https://dblp.org/rec/journals/lmcs/FruminKB21.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{compcomp,
author = {Stewart, Gordon and Beringer, Lennart and Cuellar, Santiago and Appel, Andrew W.},
title = {Compositional CompCert},
year = {2015},
isbn = {9781450333009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2676726.2676985},
doi = {10.1145/2676726.2676985},
abstract = {This paper reports on the development of Compositional CompCert, the first verified separate compiler for C.Specifying and proving separate compilation for C is made challenging by the coincidence of: compiler optimizations, such as register spilling, that introduce compiler-managed (private) memory regions into function stack frames, and C's stack-allocated addressable local variables, which may leak portions of stack frames to other modules when their addresses are passed as arguments to external function calls. The CompCert compiler, as built/proved by Leroy etal 2006--2014, has proofs of correctness for whole programs, but its simulation relations are too weak to specify or prove separately compiled modules.Our technical contributions that make Compositional CompCert possible include: language-independent linking, a new operational model of multilanguage linking that supports strong semantic contextual equivalences; and structured simulations, a refinement of Beringer etal logical simulation relations that enables expressive module-local invariants on the state communicated between compilation units at runtime. All the results in the paper have been formalized in Coq and are available for download together with the Compositional CompCert compiler.},
booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {275–287},
numpages = {13},
keywords = {compiler correctness, compcert},
location = {Mumbai, India},
series = {POPL '15}
}

@inproceedings{c11-invalid,
    author = {Vafeiadis, Viktor and Balabonski, Thibaut and Chakraborty, Soham and Morisset, Robin and Zappa Nardelli, Francesco},
    title = {Common Compiler Optimisations Are Invalid in the {C11} Memory Model and What We Can Do about It},
    year = {2015},
    isbn = {9781450333009},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2676726.2676995},
    doi = {10.1145/2676726.2676995},
    abstract = {We show that the weak memory model introduced by the 2011 C and C++ standards does not permit many common source-to-source program transformations (such as expression linearisation and "roach motel" reorderings) that modern compilers perform and that are deemed to be correct. As such it cannot be used to define the semantics of intermediate languages of compilers, as, for instance, LLVM aimed to. We consider a number of possible local fixes, some strengthening and some weakening the model. We evaluate the proposed fixes by determining which program transformations are valid with respect to each of the patched models. We provide formal Coq proofs of their correctness or counterexamples as appropriate.},
    booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    pages = {209–220},
    numpages = {12},
    keywords = {c/c++, program transformations, concurrency, compilers, weak memory models},
    location = {Mumbai, India},
    series = {POPL '15}
    }
    
@unpublished{melocoton,
  author = "Armaël Guéneau and Johannes Hostert and Simon Spies and Michael Sammler and Lars Birkedal and Derek Dreyer",
  title  = "Melocoton: A Program Logic for Verified Interoperability
Between {OCaml} and {C}",
  note   = "Unpublished draft",
  month  = "May",
  year   = "2023",
  annote = ""
}

@inproceedings{diaframe,
author = {Mulder, Ike and Krebbers, Robbert and Geuvers, Herman},
title = {Diaframe: Automated Verification of Fine-Grained Concurrent Programs in Iris},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523432},
doi = {10.1145/3519939.3523432},
abstract = {Fine-grained concurrent programs are difficult to get right, yet play an important role in modern-day computers. We want to prove strong specifications of such programs, with minimal user effort, in a trustworthy way. In this paper, we present Diaframe—an automated and foundational verification tool for fine-grained concurrent programs. Diaframe is built on top of the Iris framework for higher-order concurrent separation logic in Coq, which already has a foundational soundness proof and the ability to give strong specifications, but lacks automation. Diaframe equips Iris with strong automation using a novel, extendable, goal-directed proof search strategy, using ideas from linear logic programming and bi-abduction. A benchmark of 24 examples from the literature shows that the proof burden of Diaframe is competitive with existing non-foundational tools, while its expressivity and soundness guarantees are stronger.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {809–824},
numpages = {16},
keywords = {Iris, proof automation, fine-grained concurrency, Coq, Separation logic},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@article{later-credits,
author = {Spies, Simon and G\"{a}her, Lennard and Tassarotti, Joseph and Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
title = {Later Credits: Resourceful Reasoning for the Later Modality},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547631},
doi = {10.1145/3547631},
abstract = {In the past two decades, step-indexed logical relations and separation logics have both come to play a major role in semantics and verification research. More recently, they have been married together in the form of step-indexed separation logics like VST, iCAP, and Iris, which provide powerful tools for (among other things) building semantic models of richly typed languages like Rust. In these logics, propositions are given semantics using a step-indexed model, and step-indexed reasoning is reflected into the logic through the so-called “later” modality. On the one hand, this modality provides an elegant, high-level account of step-indexed reasoning; on the other hand, when used in sufficiently sophisticated ways, it can become a nuisance, turning perfectly natural proof strategies into dead ends. In this work, we introduce later credits, a new technique for escaping later-modality quagmires. By leveraging the second ancestor of these logics—separation logic—later credits turn “the right to eliminate a later” into an ownable resource, which is subject to all the traditional modular reasoning principles of separation logic. We develop the theory of later credits in the context of Iris, and present several challenging examples of proofs and proof patterns which were previously not possible in Iris but are now possible due to later credits.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {100},
numpages = {29},
keywords = {Iris, later modality, step-indexing, transfinite, Separation logic}
}

@inproceedings{transfinite-iris,
author = {Spies, Simon and G\"{a}her, Lennard and Gratzer, Daniel and Tassarotti, Joseph and Krebbers, Robbert and Dreyer, Derek and Birkedal, Lars},
title = {Transfinite {Iris}: Resolving an Existential Dilemma of Step-Indexed Separation Logic},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454031},
doi = {10.1145/3453483.3454031},
abstract = {Step-indexed separation logic has proven to be a powerful tool for modular reasoning about higher-order stateful programs. However, it has only been used to reason about safety properties, never liveness properties. In this paper, we observe that the inability of step-indexed separation logic to support liveness properties stems fundamentally from its failure to validate the existential property, connecting the meaning of existential quantification inside and outside the logic. We show how to validate the existential property—and thus enable liveness reasoning—by moving from finite step-indices (natural numbers) to transfinite step-indices (ordinals). Concretely, we transform the Coq-based step-indexed logic Iris to Transfinite Iris, and demonstrate its effectiveness in proving termination and termination-preserving refinement for higher-order stateful programs.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {80–95},
numpages = {16},
keywords = {Iris, step-indexing, ordinals, Separation logic, liveness properties, transfinite},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@unpublished{vst-on-iris,
  author = "William Mansky and Ke Du",
  title  = "An {Iris} Instance for Verifying {CompCert C} Programs",
  note   = "To appear in POPL 2024",
  month  = "January",
  year   = "2024",
  annote = ""
}

@inproceedings{c-defacto,
author = {Memarian, Kayvan and Matthiesen, Justus and Lingard, James and Nienhuis, Kyndylan and Chisnall, David and Watson, Robert N. M. and Sewell, Peter},
title = {Into the Depths of C: Elaborating the de Facto Standards},
year = {2016},
isbn = {9781450342612},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2908080.2908081},
doi = {10.1145/2908080.2908081},
abstract = {C remains central to our computing infrastructure. It is notionally defined by ISO standards, but in reality the properties of C assumed by systems code and those implemented by compilers have diverged, both from the ISO standards and from each other, and none of these are clearly understood. We make two contributions to help improve this error-prone situation. First, we describe an in-depth analysis of the design space for the semantics of pointers and memory in C as it is used in practice. We articulate many specific questions, build a suite of semantic test cases, gather experimental data from multiple implementations, and survey what C experts believe about the de facto standards. We identify questions where there is a consensus (either following ISO or differing) and where there are conflicts. We apply all this to an experimental C implemented above capability hardware. Second, we describe a formal model, Cerberus, for large parts of C. Cerberus is parameterised on its memory model; it is linkable either with a candidate de facto memory object model, under construction, or with an operational C11 concurrency model; it is defined by elaboration to a much simpler Core language for accessibility, and it is executable as a test oracle on small examples. This should provide a solid basis for discussion of what mainstream C is now: what programmers and analysis tools can assume and what compilers aim to implement. Ultimately we hope it will be a step towards clear, consistent, and accepted semantics for the various use-cases of C.},
booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {1–15},
numpages = {15},
keywords = {C},
location = {Santa Barbara, CA, USA},
series = {PLDI '16}
}

@inproceedings{csmith-conc,
author = {Morisset, Robin and Pawan, Pankaj and Zappa Nardelli, Francesco},
title = {Compiler Testing via a Theory of Sound Optimisations in the {C11/C++11} Memory Model},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2491967},
doi = {10.1145/2491956.2491967},
abstract = {Compilers sometimes generate correct sequential code but break the concurrency memory model of the programming language: these subtle compiler bugs are observable only when the miscompiled functions interact with concurrent contexts, making them particularly hard to detect. In this work we design a strategy to reduce the hard problem of hunting concurrency compiler bugs to differential testing of sequential code and build a tool that puts this strategy to work. Our first contribution is a theory of sound optimisations in the C11/C++11 memory model, covering most of the optimisations we have observed in real compilers and validating the claim that common compiler optimisations are sound in the C11/C++11 memory model. Our second contribution is to show how, building on this theory, concurrency compiler bugs can be identified by comparing the memory trace of compiled code against a reference memory trace for the source code. Our tool identified several mistaken write introductions and other unexpected behaviours in the latest release of the gcc compiler.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {187–196},
numpages = {10},
keywords = {c11/c++11 memory model, compiler testing},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}

@inproceedings{z3,
author = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
title = {Z3: An Efficient SMT Solver},
year = {2008},
isbn = {3540787992},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {337–340},
numpages = {4},
location = {Budapest, Hungary},
series = {TACAS'08/ETAPS'08}
}

@inproceedings{rusthornbelt,
author = {Matsushita, Yusuke and Denis, Xavier and Jourdan, Jacques-Henri and Dreyer, Derek},
title = {{RustHornBelt}: A Semantic Foundation for Functional Verification of {Rust} Programs with Unsafe Code},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523704},
doi = {10.1145/3519939.3523704},
abstract = {Rust is a systems programming language that offers both low-level memory operations and high-level safety guarantees, via a strong ownership type system that prohibits mutation of aliased state. In prior work, Matsushita et al. developed RustHorn, a promising technique for functional verification of Rust code: it leverages the strong invariants of Rust types to express the behavior of stateful Rust code with first-order logic (FOL) formulas, whose verification is amenable to off-the-shelf automated techniques. RustHorn’s key idea is to use prophecies to describe the behavior of mutable borrows. However, the soundness of RustHorn was only established for a safe subset of Rust, and it has remained unclear how to extend it to support various safe APIs that encapsulate unsafe code (i.e., code where Rust’s aliasing discipline is relaxed). In this paper, we present RustHornBelt, the first machine-checked proof of soundness for RustHorn-style verification which supports giving FOL specs to safe APIs implemented with unsafe code. RustHornBelt employs the approach of semantic typing used in Jung et al.’s RustBelt framework, but it extends RustBelt’s model to reason not only about safety but also functional correctness. The key challenge in RustHornBelt is to develop a semantic model of RustHorn-style prophecies, which we achieve via a new separation-logic mechanism we call parametric prophecies.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {841–856},
numpages = {16},
keywords = {Iris, verification, prophecy variables, Rust, separation logic, type systems},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@inproceedings{perennial,
author = {Chajed, Tej and Tassarotti, Joseph and Kaashoek, M. Frans and Zeldovich, Nickolai},
title = {Verifying Concurrent, Crash-Safe Systems with {Perennial}},
year = {2019},
isbn = {9781450368735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3341301.3359632},
doi = {10.1145/3341301.3359632},
abstract = {This paper introduces Perennial, a framework for verifying concurrent, crash-safe systems. Perennial extends the Iris concurrency framework with three techniques to enable crash-safety reasoning: recovery leases, recovery helping, and versioned memory. To ease development and deployment of applications, Perennial provides Goose, a subset of Go and a translator from that subset to a model in Perennial with support for reasoning about Go threads, data structures, and file-system primitives. We implemented and verified a crash-safe, concurrent mail server using Perennial and Goose that achieves speedup on multiple cores. Both Perennial and Iris use the Coq proof assistant, and the mail server and the framework's proofs are machine checked.},
booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
pages = {243–258},
numpages = {16},
keywords = {crash safety, separation logic, concurrency},
location = {Huntsville, Ontario, Canada},
series = {SOSP '19}
}

@inproceedings{iris-session-types,
author = {Hinrichsen, Jonas Kastberg and Louwrink, Dani\"{e}l and Krebbers, Robbert and Bengtson, Jesper},
title = {Machine-Checked Semantic Session Typing},
year = {2021},
isbn = {9781450382991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3437992.3439914},
doi = {10.1145/3437992.3439914},
abstract = {Session types—a family of type systems for message-passing concurrency—have been subject to many extensions, where each extension comes with a separate proof of type safety. These extensions cannot be readily combined, and their proofs of type safety are generally not machine checked, making their correctness less trustworthy. We overcome these shortcomings with a semantic approach to binary asynchronous affine session types, by developing a logical relations model in Coq using the Iris program logic. We demonstrate the power of our approach by combining various forms of polymorphism and recursion, asynchronous subtyping, references, and locks/mutexes. As an additional benefit of the semantic approach, we demonstrate how to manually prove typing judgements of racy, but safe, programs that cannot be type checked using only the rules of the type system.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {178–198},
numpages = {21},
keywords = {concurrency, Coq, session types, semantic typing, Iris, Message passing, separation logic},
location = {Virtual, Denmark},
series = {CPP 2021}
}

@inproceedings{cascompcert,
author = {Jiang, Hanru and Liang, Hongjin and Xiao, Siyang and Zha, Junpeng and Feng, Xinyu},
title = {Towards Certified Separate Compilation for Concurrent Programs},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314595},
doi = {10.1145/3314221.3314595},
abstract = {Certified separate compilation is important for establishing end-to-end guarantees for certified systems consisting of multiple program modules. There has been much work building certified compilers for sequential programs. In this paper, we propose a language-independent framework consisting of the key semantics components and lemmas that bridge the verification gap between the compilers for sequential programs and those for (race-free) concurrent programs, so that the existing verification work for the former can be reused. One of the key contributions of the framework is a novel footprint-preserving compositional simulation as the compilation correctness criterion. The framework also provides a new mechanism to support confined benign races which are usually found in efficient implementations of synchronization primitives. With our framework, we develop CASCompCert, which extends CompCert for certified separate compilation of race-free concurrent Clight programs. It also allows linking of concurrent Clight modules with x86-TSO implementations of synchronization primitives containing benign races. All our work has been implemented in the Coq proof assistant.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {111–125},
numpages = {15},
keywords = {Certified Compilers, Concurrency, Data-Race-Freedom, Simulations},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@article{dimsum,
author = {Sammler, Michael and Spies, Simon and Song, Youngju and D'Osualdo, Emanuele and Krebbers, Robbert and Garg, Deepak and Dreyer, Derek},
title = {{DimSum}: A Decentralized Approach to Multi-Language Semantics and Verification},
year = {2023},
issue_date = {January 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {POPL},
url = {https://doi.org/10.1145/3571220},
doi = {10.1145/3571220},
abstract = {Prior work on multi-language program verification has achieved impressive results, including the compositional verification of complex compilers. But the existing approaches to this problem impose a variety of restrictions on the overall structure of multi-language programs (e.g. fixing the source language, fixing the set of involved languages, fixing the memory model, or fixing the semantics of interoperation). In this paper, we explore the problem of how to avoid such global restrictions. Concretely, we present DimSum: a new, decentralized approach to multi-language semantics and verification, which we have implemented in the Coq proof assistant. Decentralization means that we can define and reason about languages independently from each other (as independent modules communicating via events), but also combine and translate between them when necessary (via a library of combinators). We apply DimSum to a high-level imperative language Rec (with an abstract memory model and function calls), a low-level assembly language Asm (with a concrete memory model, arbitrary jumps, and syscalls), and a mathematical specification language Spec. We evaluate DimSum on two case studies: an Asm library extending Rec with support for pointer comparison, and a coroutine library for Rec written in Asm. In both cases, we show how DimSum allows the Asm libraries to be abstracted to Rec-level specifications, despite the behavior of the Asm libraries not being syntactically expressible in Rec itself. We also verify an optimizing multi-pass compiler from Rec to Asm, showing that it is compatible with these Asm libraries.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {27},
numpages = {31},
keywords = {verification, compilers, multi-language semantics, non-determinism, Coq, separation logic, Iris}
}

@inproceedings{reynolds,
author = {Reynolds, John C.},
title = {Separation Logic: A Logic for Shared Mutable Data Structures},
year = {2002},
isbn = {0769514839},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {In joint work with Peter O'Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperativeprograms that use shared mutable data structure.The simple imperative programming language is extended with commands (not expressions) for accessing and modifying shared structures, and for explicit allocation and deallocation of storage. Assertions are extended by introducing a "separating conjunction" that asserts that its sub-formulas hold for disjoint parts of the heap, and a closely related "separating implication". Coupled with the inductive definition of predicates on abstract data structures, this extension permits the concise and flexible description of structures with controlled sharing.In this paper, we will survey the current development of this program logic, including extensions that permit unrestricted address arithmetic, dynamically allocated arrays, and recursive procedures. We will also discuss promising future directions.},
booktitle = {Proceedings of the 17th Annual IEEE Symposium on Logic in Computer Science},
pages = {55–74},
numpages = {20},
series = {LICS '02}
}

@article{compcerttso,
author = {\v{S}ev\v{c}\'{\i}k, Jaroslav and Vafeiadis, Viktor and Zappa Nardelli, Francesco and Jagannathan, Suresh and Sewell, Peter},
title = {CompCertTSO: A Verified Compiler for Relaxed-Memory Concurrency},
year = {2013},
issue_date = {June 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {60},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/2487241.2487248},
doi = {10.1145/2487241.2487248},
abstract = {In this article, we consider the semantic design and verified compilation of a C-like programming language for concurrent shared-memory computation on x86 multiprocessors. The design of such a language is made surprisingly subtle by several factors: the relaxed-memory behavior of the hardware, the effects of compiler optimization on concurrent code, the need to support high-performance concurrent algorithms, and the desire for a reasonably simple programming model. In turn, this complexity makes verified compilation both essential and challenging.We describe ClightTSO, a concurrent extension of CompCert’s Clight in which the TSO-based memory model of x86 multiprocessors is exposed for high-performance code, and CompCertTSO, a formally verified compiler from ClightTSO to x86 assembly language, building on CompCert. CompCertTSO is verified in Coq: for any well-behaved and successfully compiled ClightTSO source program, any permitted observable behavior of the generated assembly code (if it does not run out of memory) is also possible in the source semantics. We also describe some verified fence-elimination optimizations, integrated into CompCertTSO.},
journal = {J. ACM},
month = {jun},
articleno = {22},
numpages = {50},
keywords = {Relaxed memory models, semantics, verified compilation}
}

@inproceedings{ironclad,
author = {Hawblitzel, Chris and Howell, Jon and Lorch, Jacob R. and Narayan, Arjun and Parno, Bryan and Zhang, Danfeng and Zill, Brian},
title = {Ironclad Apps: End-to-End Security via Automated Full-System Verification},
year = {2014},
isbn = {9781931971164},
publisher = {USENIX Association},
address = {USA},
abstract = {An Ironclad App lets a user securely transmit her data to a remote machine with the guarantee that every instruction executed on that machine adheres to a formal abstract specification of the app's behavior. This does more than eliminate implementation vulnerabilities such as buffer overflows, parsing errors, or data leaks; it tells the user exactly how the app will behave at all times. We provide these guarantees via complete, low-level software verification. We then use cryptography and secure hardware to enable secure channels from the verified software to remote users. To achieve such complete verification, we developed a set of new and modified tools, a collection of techniques and engineering disciplines, and a methodology focused on rapid development of verified systems software. We describe our methodology, formal results, and lessons we learned from building a full stack of verified software. That software includes a verified kernel; verified drivers; verified system and crypto libraries including SHA, HMAC, and RSA; and four Ironclad Apps.},
booktitle = {Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation},
pages = {165–181},
numpages = {17},
location = {Broomfield, CO},
series = {OSDI'14}
}

@inproceedings{ironfleet,
author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jacob R. and Parno, Bryan and Roberts, Michael L. and Setty, Srinath and Zill, Brian},
title = {IronFleet: Proving Practical Distributed Systems Correct},
year = {2015},
isbn = {9781450338349},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2815400.2815428},
doi = {10.1145/2815400.2815428},
abstract = {Distributed systems are notorious for harboring subtle bugs. Verification can, in principle, eliminate these bugs a priori, but verification has historically been difficult to apply at full-program scale, much less distributed-system scale.We describe a methodology for building practical and provably correct distributed systems based on a unique blend of TLA-style state-machine refinement and Hoare-logic verification. We demonstrate the methodology on a complex implementation of a Paxos-based replicated state machine library and a lease-based sharded key-value store. We prove that each obeys a concise safety specification, as well as desirable liveness requirements. Each implementation achieves performance competitive with a reference system. With our methodology and lessons learned, we aim to raise the standard for distributed systems from "tested" to "correct."},
booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
pages = {1–17},
numpages = {17},
location = {Monterey, California},
series = {SOSP '15}
}

@article{iris-compcert,
author = {Mansky, William and Du, Ke},
title = {An Iris Instance for Verifying CompCert C Programs},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632848},
doi = {10.1145/3632848},
abstract = {Iris is a generic separation logic framework that has been instantiated to reason about a wide range of programming languages and language features. Most Iris instances are defined on simple core calculi, but by connecting Iris to new or existing formal semantics for practical languages, we can also use it to reason about real programs. In this paper we develop an Iris instance based on CompCert, the verified C compiler, allowing us to prove correctness of C programs under the same semantics we use to compile and run them. We take inspiration from the Verified Software Toolchain (VST), a prior separation logic for CompCert C, and reimplement the program logic of VST in Iris. Unlike most Iris instances, this involves both a new model of resources for CompCert memories, and a new definition of weakest preconditions/Hoare triples, as the Iris defaults for both of these cannot be applied to CompCert as is. Ultimately, we obtain a complete program logic for CompCert C within Iris, and we reconstruct enough of VST's top-level automation to prove correctness of simple C programs.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {6},
numpages = {27},
keywords = {Iris, Verified Software Toolchain, concurrent separation logic, interactive theorem proving, program verification}
}

@inproceedings{nextgen,
author = {Vindum, Simon Friis and Georges, A\"{\i}na Linn and Birkedal, Lars},
title = {The Nextgen Modality: A Modality for Non-Frame-Preserving Updates in Separation Logic},
year = {2025},
isbn = {9798400713477},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3703595.3705876},
doi = {10.1145/3703595.3705876},
abstract = {As separation logic is a logic of resources, the way in which resources can soundly change and be updated is a fundamental aspect. Such changes have typically been restricted to certain local or frame-preserving updates. However, recently we have seen separation logics where the restriction to frame-preserving updates seems to be a hindrance towards achieving the ideal program reasoning rules. In this, paper we propose a novel nextgen modality that enables reasoning across generations where each generational change can update resources in ways that are non-local and non-frame-preserving. We implement the idea as an extension to the Iris base logic, which enriches Iris with an entirely new capability: the ability to make non-frame-preserving updates to ghost state. We show that two existing Iris modalities are special cases of the nextgen modality. Our “extension” can thus also be seen as a generalization and simplification of the Iris base logic. To demonstrate the utility of the nextgen modality we use it to construct a separation logic for a programming language with explicit stack allocation and with a return operation that clears entire stack frames. The nextgen modality is used to great effect in the reasoning rule for return, where a modular and practical reasoning rule is otherwise out of reach. This is the first separation logic for a high-level programming language with stack allocation. We sketch ideas for future work in other domains where we think the nextgen modality can be useful.},
booktitle = {Proceedings of the 14th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {83–97},
numpages = {15},
keywords = {Coq, Iris, modality, program logic, separation logic},
location = {Denver, CO, USA},
series = {CPP '25}
}

@InProceedings{cminor-logic,
author="Appel, Andrew W.
and Blazy, Sandrine",
editor="Schneider, Klaus
and Brandt, Jens",
title="Separation Logic for Small-Step Cminor",
booktitle="Theorem Proving in Higher Order Logics",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="5--21",
abstract="cminor is a mid-level imperative programming language; there are proved-correct optimizing compilers from C to cminor and from cminor to machine language. We have redesigned cminor so that it is suitable for Hoare Logic reasoning and we have designed a Separation Logic for cminor. In this paper, we give a small-step semantics (instead of the big-step of the proved-correct compiler) that is motivated by the need to support future concurrent extensions. We detail a machine-checked proof of soundness of our Separation Logic. This is the first large-scale machine-checked proof of a Separation Logic w.r.t. a small-step semantics. The work presented in this paper has been carried out in the Coq proof assistant. It is a first step towards an environment in which concurrent cminor programs can be verified using Separation Logic and also compiled by a proved-correct compiler with formal end-to-end correctness guarantees.",
isbn="978-3-540-74591-4"
}

@article{iris-callcc,
author = {Timany, Amin and Birkedal, Lars},
title = {Mechanized relational verification of concurrent programs with continuations},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341709},
doi = {10.1145/3341709},
abstract = {Concurrent higher-order imperative programming languages with continuations are very flexible and allow for the implementation of sophisticated programming patterns. For instance, it is well known that continuations can be used to implement cooperative concurrency. Continuations can also simplify web server implementations. This, in particular, helps simplify keeping track of the state of server’s clients. However, such advanced programming languages are very challenging to reason about. One of the main challenges in reasoning about programs in the presence of continuations is due to the fact that the non-local flow of control breaks the bind rule, one of the important modular reasoning principles of Hoare logic. In this paper we present the first completely formalized tool for interactive mechanized relational verification of programs written in a concurrent higher-order imperative programming language with continuations (call/cc and throw). We develop novel logical relations which can be used to give mechanized proofs of relational properties. In particular, we prove correctness of an implementation of cooperative concurrency with continuations. In addition, we show that that a rudimentary web server implemented using the continuation-based pattern is contextually equivalent to one implemented without the continuation-based pattern. We introduce context-local reasoning principles for our calculus which allows us to regain modular reasoning principles for the fragment of the language without non-local control flow. These novel reasoning principles can be used in tandem with our (non-context-local) Hoare logic for reasoning about programs that do feature non-local control flow. Indeed, we use the combination of context-local and non-context-local reasoning to simplify reasoning about the examples.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {105},
numpages = {28},
keywords = {Concurrency, Continuations, Logical relations}
}

@article{refinedrust,
author = {G\"{a}her, Lennard and Sammler, Michael and Jung, Ralf and Krebbers, Robbert and Dreyer, Derek},
title = {RefinedRust: A Type System for High-Assurance Verification of Rust Programs},
year = {2024},
issue_date = {June 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {PLDI},
url = {https://doi.org/10.1145/3656422},
doi = {10.1145/3656422},
abstract = {Rust is a modern systems programming language whose ownership-based type system statically guarantees memory safety, making it particularly well-suited to the domain of safety-critical systems. In recent years, a wellspring of automated deductive verification tools have emerged for establishing functional correctness of Rust code. However, none of the previous tools produce foundational proofs (machine-checkable in a generalpurpose proof assistant), and all of them are restricted to the safe fragment of Rust. This is a problem because the vast majority of Rust programs make use of unsafe code at critical points, such as in the implementation of widely-used APIs. We propose RefinedRust, a refinement type system—proven sound in the Coq proof assistant—with the goal of establishing foundational semi-automated functional correctness verification of both safe and unsafe Rust code. We have developed a prototype verification tool implementing RefinedRust. Our tool translates Rust code (with user annotations) into a model of Rust embedded in Coq, and then checks its adherence to the RefinedRust type system using separation logic automation in Coq. All proofs generated by RefinedRust are checked by the Coq proof assistant, so the automation and type system do not have to be trusted. We evaluate the effectiveness of RefinedRust by verifying a variant of Rust’s Vec implementation that involves intricate reasoning about unsafe pointer-manipulating code.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {192},
numpages = {25},
keywords = {separation logic, program verification, Rust, Iris}
}

@inproceedings{cakeml,
  author = {Ramana Kumar and
            Magnus O. Myreen and
            Michael Norrish and
            Scott Owens},
  title = {{CakeML}: A Verified Implementation of {ML}},
  month = jan,
  year = 2014,
  pages = {179--191},
  publisher = {ACM Press},
  url = {https://cakeml.org/popl14.pdf},
  booktitle = {Principles of Programming Languages ({POPL})},
  doi = {10.1145/2535838.2535841}
}

@inproceedings{cfml,
author = {Chargu\'{e}raud, Arthur},
title = {Characteristic formulae for the verification of imperative programs},
year = {2011},
isbn = {9781450308656},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2034773.2034828},
doi = {10.1145/2034773.2034828},
abstract = {In previous work, we introduced an approach to program verification based on characteristic formulae. The approach consists of generating a higher-order logic formula from the source code of a program. This characteristic formula is constructed in such a way that it gives a sound and complete description of the semantics of that program. The formula can thus be exploited in an interactive proof assistant to formally verify that the program satisfies a particular specification.This previous work was, however, only concerned with purely-functional programs. In the present paper, we describe the generalization of characteristic formulae to an imperative programming language. In this setting, characteristic formulae involve specifications expressed in the style of Separation Logic. They also integrate the frame rule, which enables local reasoning. We have implemented a tool based on characteristic formulae. This tool, called CFML, supports the verification of imperative Caml programs using the Coq proof assistant. Using CFML, we have formally verified nontrivial imperative algorithms, as well as CPS functions, higher-order iterators, and programs involving higher-order stores.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Functional Programming},
pages = {418–430},
numpages = {13},
keywords = {characteristic formula, interactive verification, total correctness},
location = {Tokyo, Japan},
series = {ICFP '11}
}

@Book{ISO:2024:IIP,
  author =       "{ISO}",
  title =        "{ISO\slash IEC 14882:2024 Programming languages ---
                 C++}",
  publisher =    pub-ISO,
  address =      pub-ISO:adr,
  edition =      "Seventh",
  pages =        "2104",
  month =        oct,
  year =         "2024",
  ISBN =         "????",
  ISBN-13 =      "????",
  LCCN =         "????",
  bibdate =      "Wed Apr 30 14:48:53 2025",
  bibsource =    "https://www.math.utah.edu/pub/tex/bib/isostd.bib",
  URL =          "https://www.iso.org/standard/83626.html",
  acknowledgement = ack-nhfb,
}

@misc{brick,
  title = "The {BRiCk} Project",
  authors = "Gregory Malecha, Paolo Giarrusso, David Swasey, Hai Dang, František Farka, Abhishek Anand, Hai Dang",
  howpublished = {\url{https://github.com/SkylabsAI/brick}},
  year = {2025}
}